<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="description" content="RAPP - Your Digital Twin. AI that knows you, remembers everything, and evolves with your needs." />
  <meta name="theme-color" content="#742774" />
  <title>RAPP - Your Digital Twin</title>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark.min.css" rel="stylesheet" />

  <style>
    :root {
      --primary: #742774;
      --primary-light: #9168b6;
      --primary-dark: #4f1c4f;
      --primary-rgb: 116, 39, 116;
      --secondary: #00bcd4;
      --secondary-light: #4dd0e1;
      --accent: #ff4081;
      --success: #4caf50;
      --error: #f44336;
      --warning: #ff9800;
      --info: #2196f3;

      --gray-10: #faf9f8;
      --gray-20: #f3f2f1;
      --gray-30: #edebe9;
      --gray-40: #e1dfdd;
      --gray-50: #d2d0ce;
      --gray-60: #c8c6c4;
      --gray-80: #605e5c;
      --gray-100: #323130;
      --gray-130: #242424;

      --space-xs: 4px;
      --space-s: 8px;
      --space-m: 16px;
      --space-l: 24px;
      --space-xl: 32px;
      --space-xxl: 48px;

      --radius: 8px;
      --radius-small: 4px;
      --radius-large: 16px;
      --radius-full: 9999px;

      --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.08);
      --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.12);
      --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.16);

      --header-height: 56px;
      --input-container-height: 80px;
      --safe-area-top: env(safe-area-inset-top);
      --safe-area-bottom: env(safe-area-inset-bottom);

      --transition: all 0.2s ease;
    }

    /* Dark mode variables */
    body.dark {
      --gray-10: #1a1a1a;
      --gray-20: #242424;
      --gray-30: #2d2d2d;
      --gray-40: #373737;
      --gray-50: #424242;
      --gray-60: #4d4d4d;
      --gray-80: #8a8a8a;
      --gray-100: #e0e0e0;
      --gray-130: #f5f5f5;
      --primary-light: #a47cc9;
      --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    /* Allow text selection globally */
    body,
    div,
    span,
    p,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    code,
    pre {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    /* Only disable selection for interactive elements */
    button,
    .button,
    .fab,
    label,
    .clickable {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        sans-serif;
      background: var(--gray-10);
      color: var(--gray-100);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    /* Mention Autocomplete Dropdown */
    .mention-dropdown {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      max-height: 200px;
      overflow-y: auto;
      display: none;
      box-shadow: var(--shadow-medium);
      z-index: 100;
    }

    body.dark .mention-dropdown {
      background: var(--gray-30);
    }

    .mention-dropdown.active {
      display: block;
      animation: slideUp 0.2s ease-out;
    }

    .mention-item {
      padding: var(--space-m);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: var(--space-m);
      border-bottom: 1px solid var(--gray-20);
    }

    body.dark .mention-item {
      border-bottom-color: var(--gray-40);
    }

    .mention-item:last-child {
      border-bottom: none;
    }

    .mention-item:hover,
    .mention-item.selected {
      background: rgba(var(--primary-rgb), 0.08);
    }

    .mention-item-icon {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
    }

    .mention-item-info {
      flex: 1;
    }

    .mention-item-name {
      font-weight: 600;
      color: var(--gray-100);
      font-size: 14px;
    }

    .mention-item-url {
      font-size: 12px;
      color: var(--gray-60);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Mention Tag in Messages */
    .mention-tag {
      background: rgba(var(--primary-rgb), 0.15);
      color: var(--primary);
      padding: 2px 8px;
      border-radius: var(--radius-small);
      font-weight: 600;
      display: inline-block;
      margin: 0 2px;
    }

    body.dark .mention-tag {
      background: rgba(var(--primary-rgb), 0.25);
      color: var(--primary-light);
    }

    /* Endpoint Badge */
    .endpoint-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: rgba(var(--primary-rgb), 0.1);
      border-radius: var(--radius-full);
      font-size: 12px;
      font-weight: 600;
      color: var(--primary);
      margin-left: var(--space-s);
    }

    .endpoint-badge i {
      font-size: 10px;
    }

    /* Agent Output Styles */
    .agent-output-wrapper {
      margin: var(--space-m) 0;
      background: rgba(var(--primary-rgb), 0.05);
      border: 1px solid rgba(var(--primary-rgb), 0.15);
      border-radius: var(--radius);
      overflow: hidden;
      transition: var(--transition);
    }

    body.dark .agent-output-wrapper {
      background: rgba(var(--primary-rgb), 0.1);
      border-color: rgba(var(--primary-rgb), 0.2);
    }

    .agent-output-header {
      padding: var(--space-m);
      background: rgba(var(--primary-rgb), 0.08);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      transition: var(--transition);
    }

    body.dark .agent-output-header {
      background: rgba(var(--primary-rgb), 0.15);
    }

    .agent-output-header:hover {
      background: rgba(var(--primary-rgb), 0.12);
    }

    body.dark .agent-output-header:hover {
      background: rgba(var(--primary-rgb), 0.2);
    }

    .agent-output-title {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      font-size: 14px;
      font-weight: 600;
      color: var(--primary);
    }

    .agent-output-title i {
      font-size: 16px;
    }

    .agent-output-toggle {
      background: none;
      border: none;
      color: var(--gray-60);
      cursor: pointer;
      transition: var(--transition);
      padding: 4px;
    }

    .agent-output-toggle:hover {
      color: var(--primary);
    }

    .agent-output-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .agent-output-content.expanded {
      max-height: 1000px;
      overflow-y: auto;
    }

    .agent-output-text {
      padding: var(--space-m);
      font-family: monospace;
      font-size: 13px;
      color: var(--gray-80);
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
    }

    body.dark .agent-output-text {
      color: var(--gray-100);
    }

    /* Simple Link Styles */
    .link-wrapper {
      display: inline;
      margin: 0 2px;
    }

    .link-wrapper a {
      color: var(--primary);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .link-wrapper a:hover {
      text-decoration: underline;
      color: var(--primary-light);
    }

    .link-wrapper i {
      font-size: 12px;
    }

    /* Endpoint Management Styles */
    .endpoint-list {
      margin-top: var(--space-m);
    }

    .endpoint-item {
      padding: var(--space-m);
      background: var(--gray-20);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      display: flex;
      align-items: center;
      gap: var(--space-m);
      transition: var(--transition);
    }

    body.dark .endpoint-item {
      background: var(--gray-30);
    }

    .endpoint-item:hover {
      background: var(--gray-30);
    }

    body.dark .endpoint-item:hover {
      background: var(--gray-40);
    }

    .endpoint-item-icon {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .endpoint-item-info {
      flex: 1;
      min-width: 0;
    }

    .endpoint-item-name {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: 2px;
    }

    .endpoint-item-url {
      font-size: 12px;
      color: var(--gray-60);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .endpoint-item-actions {
      display: flex;
      gap: var(--space-s);
    }

    .endpoint-item-action {
      background: var(--gray-30);
      border: none;
      color: var(--gray-80);
      width: 32px;
      height: 32px;
      border-radius: var(--radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }

    body.dark .endpoint-item-action {
      background: var(--gray-40);
    }

    .endpoint-item-action:hover {
      background: var(--primary);
      color: white;
    }

    .endpoint-item-action.active {
      background: var(--success);
      color: white;
    }

    /* RAPPID Backup Buttons */
    .settings-import-export {
      display: flex;
      gap: var(--space-m);
      margin-bottom: var(--space-xl);
      padding-bottom: var(--space-xl);
      border-bottom: 1px solid var(--gray-30);
    }

    .settings-import-export button {
      flex: 1;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 0.9;
      }

      50% {
        opacity: 0.6;
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    @keyframes gentleBounce {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-3px);
      }
    }

    /* Nice button press effect */
    button:active, .btn:active, .header-button:active, .input-button:active {
      transform: scale(0.95) !important;
      transition: transform 0.1s ease !important;
    }

    /* Subtle glow on primary buttons */
    .btn-primary, .send-btn, #send-button {
      box-shadow: 0 2px 8px rgba(116, 39, 116, 0.3);
      transition: all 0.2s ease;
    }

    .btn-primary:hover, .send-btn:hover, #send-button:hover {
      box-shadow: 0 4px 16px rgba(116, 39, 116, 0.4);
    }

    /* Smooth input focus glow */
    .input-field:focus {
      box-shadow: 0 0 0 3px rgba(116, 39, 116, 0.15);
    }

    /* Message hover effect */
    .message-bubble {
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .message-bubble:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    /* Typing indicator enhancement */
    .loading span {
      animation: gentleBounce 0.6s ease-in-out infinite;
    }

    .loading span:nth-child(2) {
      animation-delay: 0.1s;
    }

    .loading span:nth-child(3) {
      animation-delay: 0.2s;
    }

    /* Sidebar item hover slide */
    .chat-item {
      transition: all 0.2s ease;
    }

    .chat-item:hover {
      transform: translateX(4px);
      background: rgba(116, 39, 116, 0.08);
    }

    /* Header logo subtle animation on hover */
    .header-title:hover {
      color: var(--primary);
      cursor: pointer;
    }

    /* Link underline animation */
    a {
      position: relative;
    }

    /* Card/modal entrance */
    .modal-content, .settings-panel, .tool-gallery-content {
      animation: scaleIn 0.2s ease-out;
    }

    /* Skeleton loading shimmer for future use */
    .skeleton {
      background: linear-gradient(90deg, var(--gray-20) 25%, var(--gray-30) 50%, var(--gray-20) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: var(--radius);
    }

    /* Login Page */
    .login-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg,
          var(--primary) 0%,
          var(--primary-dark) 100%);
      padding: var(--space-m);
      animation: fadeIn 0.5s ease-out;
    }

    .login-box {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: var(--space-xl);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow-large);
      width: 100%;
      max-width: 420px;
      animation: scaleIn 0.5s ease-out;
    }

    body.dark .login-box {
      background: rgba(36, 36, 36, 0.95);
    }

    .login-header {
      text-align: center;
      margin-bottom: var(--space-xl);
    }

    .login-header h1 {
      color: var(--primary);
      font-size: 32px;
      font-weight: 700;
      margin-bottom: var(--space-s);
    }

    .login-header p {
      color: var(--gray-80);
      opacity: 0.8;
      font-size: 16px;
    }

    .form-group {
      margin-bottom: var(--space-l);
    }

    .form-group label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: var(--gray-80);
      margin-bottom: var(--space-s);
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 14px 18px;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      font-size: 16px;
      transition: var(--transition);
      background: var(--gray-20);
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--primary);
      background: white;
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
    }

    body.dark .form-group input:focus,
    body.dark .form-group select:focus {
      background: var(--gray-30);
    }

    .login-button {
      width: 100%;
      background: var(--primary);
      color: white;
      border: none;
      padding: 14px 28px;
      border-radius: var(--radius);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      margin-top: var(--space-m);
    }

    .login-button:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .user-list {
      margin-top: var(--space-xl);
      padding-top: var(--space-xl);
      border-top: 1px solid var(--gray-30);
    }

    .user-list h3 {
      font-size: 16px;
      color: var(--gray-80);
      margin-bottom: var(--space-m);
      font-weight: 600;
    }

    .user-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-m);
      background: var(--gray-20);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      cursor: pointer;
      transition: var(--transition);
    }

    .user-item:hover {
      background: var(--gray-30);
      transform: translateX(4px);
    }

    /* Main App Container */
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--gray-10);
      overflow: hidden;
    }

    /* Header */
    .header {
      background: white;
      color: var(--gray-100);
      padding: 0 var(--space-l);
      padding-top: var(--safe-area-top);
      height: calc(var(--header-height) + var(--safe-area-top));
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      z-index: 100;
      flex-shrink: 0;
      border-bottom: 1px solid var(--gray-20);
    }

    body.dark .header {
      background: #1a1a1a;
      border-bottom-color: var(--gray-30);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: var(--space-l);
    }

    .header-title {
      font-size: 20px;
      font-weight: 600;
      display: flex;
      align-items: center;
      letter-spacing: -0.02em;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    /* Separator for header button groups */
    .header-actions::after {
      content: '';
      width: 1px;
      height: 24px;
      background: var(--gray-30);
      margin: 0 var(--space-s);
      display: none;
    }

    .header-button {
      background: transparent;
      border: none;
      color: var(--gray-70);
      width: 36px;
      height: 36px;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 16px;
    }

    .header-button:hover {
      background: var(--gray-20);
      color: var(--primary);
      transform: translateY(-1px);
    }

    body.dark .header-button {
      color: var(--gray-100);
    }

    body.dark .header-button:hover {
      background: var(--gray-30);
      color: var(--primary);
    }

    /* Voice indicator in header */
    .voice-indicator {
      display: none;
      align-items: center;
      gap: var(--space-s);
      padding: 6px 12px;
      background: var(--primary);
      color: white;
      border-radius: var(--radius-full);
      font-size: 13px;
      font-weight: 500;
      animation: fadeIn 0.3s ease-out;
    }

    .voice-indicator.active {
      display: flex;
    }

    .voice-indicator i {
      font-size: 14px;
      animation: pulse 1.5s infinite;
    }

    /* Sidebar */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 85%;
      max-width: 340px;
      background: white;
      box-shadow: var(--shadow-large);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 200;
      overflow-y: auto;
    }

    body.dark .sidebar {
      background: #1a1a1a;
      box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
    }

    .sidebar.open {
      transform: translateX(0);
    }

    .sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 190;
      backdrop-filter: blur(4px);
    }

    .sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .sidebar-header {
      padding: var(--space-l);
      padding-top: calc(var(--space-l) + var(--safe-area-top));
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .sidebar-header h2 {
      font-size: 20px;
      font-weight: 600;
    }

    .sidebar-tabs {
      display: flex;
      background: var(--gray-10);
      position: sticky;
      top: calc(80px + var(--safe-area-top));
      z-index: 9;
    }

    body.dark .sidebar-tabs {
      background: var(--gray-30);
    }

    .sidebar-tab {
      flex: 1;
      padding: var(--space-m);
      background: none;
      border: none;
      color: var(--gray-60);
      cursor: pointer;
      transition: var(--transition);
      border-bottom: 3px solid transparent;
      font-size: 15px;
      font-weight: 500;
    }

    .sidebar-tab:hover {
      color: var(--gray-100);
    }

    .sidebar-tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .chat-list {
      padding: var(--space-m);
      min-height: 300px;
    }

    .chat-list-empty {
      padding: var(--space-xl);
      text-align: center;
      color: var(--gray-60);
    }

    .chat-item {
      padding: var(--space-m);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      background: var(--gray-10);
    }

    body.dark .chat-item {
      background: var(--gray-30);
    }

    .chat-item:hover {
      background: var(--gray-20);
      transform: translateX(4px);
    }

    body.dark .chat-item:hover {
      background: var(--gray-40);
    }

    .chat-item.active {
      background: rgba(var(--primary-rgb), 0.08);
      border-left: 3px solid var(--primary);
    }

    .chat-item-title {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: var(--space-xs);
      padding-right: 60px;
    }

    .chat-item-preview {
      font-size: 14px;
      color: var(--gray-60);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-item-date {
      font-size: 12px;
      color: var(--gray-60);
      margin-top: var(--space-xs);
    }

    .chat-item-actions {
      position: absolute;
      top: var(--space-m);
      right: var(--space-m);
      display: flex;
      gap: var(--space-xs);
      opacity: 0;
      transition: var(--transition);
    }

    .chat-item:hover .chat-item-actions {
      opacity: 1;
    }

    .chat-item-action {
      background: var(--gray-30);
      border: none;
      color: var(--gray-80);
      width: 32px;
      height: 32px;
      border-radius: var(--radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }

    .chat-item-action:hover {
      background: var(--primary);
      color: white;
    }

    /* Chat Container */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-10);
      min-height: 0;
    }

    body.dark .chat-container {
      background: #0f0f0f;
    }

    .chat-messages-wrapper {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: var(--space-xl);
      padding-bottom: var(--space-xl);
      scroll-behavior: smooth;
      position: relative;
      min-height: 0;
    }

    @media (min-width: 1024px) {
      .chat-messages {
        padding: var(--space-xl) 10%;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
      }
    }

    /* Welcome screen for empty chat */
    .chat-messages:empty::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      color: white;
      box-shadow: 0 10px 40px rgba(116, 39, 116, 0.3);
    }

    .chat-messages:empty::after {
      content: 'Welcome to RAPP\A Start a conversation below';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, calc(-50% + 80px));
      text-align: center;
      color: var(--gray-60);
      font-size: 18px;
      font-weight: 500;
      white-space: pre-line;
      line-height: 1.6;
      margin-top: var(--space-l);
    }

    /* Welcome Icon (replaces pseudo-elements when active) */
    .welcome-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1;
    }

    .welcome-icon-square {
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      box-shadow: 0 10px 40px rgba(116, 39, 116, 0.3);
      transition: transform 0.15s ease-out;
      transform-style: preserve-3d;
      cursor: pointer;
    }

    .welcome-icon-square:hover {
      transform: scale(1.05);
    }

    .welcome-icon-square .robot-icon {
      font-size: 48px;
      color: white;
      transition: transform 0.1s ease-out;
    }

    .welcome-icon-square.qr-active {
      background: white;
      padding: 15px;
    }

    .welcome-icon-square canvas {
      border-radius: 10px;
    }

    .welcome-text {
      margin-top: 20px;
      color: var(--gray-60);
      font-size: 18px;
      font-weight: 500;
      line-height: 1.6;
    }

    .welcome-text.sharing-active {
      color: var(--primary);
      font-weight: 600;
    }

    body.dark .welcome-text {
      color: var(--gray-80);
    }

    .welcome-help {
      margin-top: 32px;
    }

    /* Hide pseudo-elements when welcome-icon exists */
    .chat-messages:has(.welcome-icon)::before,
    .chat-messages:has(.welcome-icon)::after {
      display: none;
    }

    body.dark .chat-messages:empty::after {
      color: var(--gray-50);
    }

    /* Messages - Allow text selection */
    .message-wrapper {
      margin: var(--space-l) 0;
      animation: slideUp 0.3s ease-out;
      max-width: 75%;
    }

    .message-wrapper.user {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .message-wrapper.assistant {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .message-label {
      font-size: 12px;
      color: var(--gray-60);
      margin-bottom: 6px;
      font-weight: 600;
      padding: 0 4px;
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    body.dark .message-label {
      color: #999;
    }

    .message-content {
      padding: 16px 20px;
      border-radius: 16px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      font-size: 15px;
      line-height: 1.6;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
      transition: all 0.2s ease;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      cursor: text;
    }

    .message-content:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .user .message-content {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border-bottom-right-radius: 4px;
      box-shadow: 0 2px 8px rgba(116, 39, 116, 0.25);
    }

    .user .message-content:hover {
      box-shadow: 0 4px 16px rgba(116, 39, 116, 0.35);
    }

    .assistant .message-content {
      background: white;
      border: 1px solid var(--gray-20);
      color: var(--gray-100);
      border-bottom-left-radius: var(--space-xs);
    }

    body.dark .assistant .message-content {
      background: #2a2a2a;
      border-color: var(--gray-40);
      color: #e8e8e8;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    body.dark .message-content:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
    }

    body.dark .message-content code {
      background: rgba(116, 39, 116, 0.2);
      border-color: rgba(116, 39, 116, 0.3);
      color: #e8e8e8;
    }

    /* Style links in messages */
    .assistant .message-content a {
      color: var(--primary);
      text-decoration: underline;
    }

    .assistant .message-content a:hover {
      color: var(--primary-dark);
    }

    body.dark .assistant .message-content a {
      color: #bb86fc;
    }

    body.dark .assistant .message-content a:hover {
      color: #d7acff;
    }

    .user .message-content a {
      color: white !important;
      text-decoration: underline;
    }

    .user .message-content a:hover {
      opacity: 0.8;
    }

    .system-message {
      background: rgba(var(--primary-rgb), 0.05);
      padding: var(--space-m);
      border-radius: var(--radius);
      margin: var(--space-l) auto;
      width: 90%;
      font-family: monospace;
      font-size: 13px;
      border: 1px solid rgba(var(--primary-rgb), 0.1);
      color: var(--gray-80);
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: pre-wrap;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      cursor: text;
    }

    body.dark .system-message {
      background: rgba(var(--primary-rgb), 0.1);
      color: var(--gray-100);
    }

    /* Voice message indicator with broadcast animation */
    .voice-message {
      display: none;
      align-items: center;
      gap: var(--space-s);
      margin-top: var(--space-s);
      padding: 8px 12px;
      background: rgba(var(--primary-rgb), 0.1);
      border-radius: var(--radius);
      font-size: 13px;
      color: var(--primary);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .voice-message.active {
      display: flex;
    }

    .voice-message:hover {
      background: rgba(var(--primary-rgb), 0.15);
      transform: translateY(-1px);
    }

    .voice-message-icon {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      flex-shrink: 0;
    }

    /* Pulsing broadcast animation */
    .voice-message:not(.expanded) .voice-message-icon::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: var(--primary);
      opacity: 0;
      animation: broadcastPulse 2s ease-out infinite;
    }

    .voice-message:not(.expanded) .voice-message-icon::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: var(--primary);
      opacity: 0;
      animation: broadcastPulse 2s ease-out infinite 1s;
    }

    @keyframes broadcastPulse {
      0% {
        transform: scale(1);
        opacity: 0.6;
      }
      50% {
        opacity: 0.3;
      }
      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    .voice-message i {
      font-size: 14px;
      position: relative;
      z-index: 1;
      animation: iconPulse 2s ease-in-out infinite;
    }

    @keyframes iconPulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
    }

    .voice-message.expanded i {
      animation: none;
      transform: scale(1);
    }

    .voice-message-content {
      max-width: 0;
      opacity: 0;
      overflow: hidden;
      white-space: nowrap;
      transition: max-width 0.4s ease, opacity 0.3s ease;
    }

    .voice-message.expanded .voice-message-content {
      max-width: 500px;
      opacity: 1;
    }

    body.dark .voice-message {
      background: rgba(116, 39, 116, 0.15);
      color: #bb86fc;
    }

    body.dark .voice-message:hover {
      background: rgba(116, 39, 116, 0.25);
    }

    body.dark .voice-message:not(.expanded) .voice-message-icon::before,
    body.dark .voice-message:not(.expanded) .voice-message-icon::after {
      background: #bb86fc;
    }

    /* Better visibility for lists and quotes in dark mode */
    body.dark .message-content ul,
    body.dark .message-content ol {
      color: #e8e8e8;
    }

    body.dark .message-content blockquote {
      border-left-color: #bb86fc;
      color: #b8b8b8;
    }

    body.dark .message-content hr {
      border-color: var(--gray-40);
    }

    .message-content pre {
      background: #f6f8fa;
      padding: var(--space-m);
      border-radius: 8px;
      overflow-x: auto;
      margin: var(--space-m) 0;
      font-size: 13px;
      border: 1px solid var(--gray-20);
      line-height: 1.5;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    body.dark .message-content pre {
      background: #161b22;
      border-color: var(--gray-40);
    }

    .message-content code {
      background: rgba(116, 39, 116, 0.08);
      padding: 3px 8px;
      border-radius: 6px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
      font-size: 13px;
      border: 1px solid rgba(116, 39, 116, 0.1);
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    .user .message-content pre,
    .user .message-content code {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Loading Animation - Matching Copilot for Sales Voice */
    .loading {
      display: none !important;
      margin: var(--space-m) 0;
      margin-right: auto;
      max-width: 80px;
      background: var(--gray-20);
      padding: 14px 20px;
      border-radius: var(--radius-large);
      border-bottom-left-radius: var(--space-xs);
      box-shadow: var(--shadow-small);
    }

    body.dark .loading {
      background: var(--gray-30);
    }

    .loading.active {
      display: flex !important;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
      animation: slideUp 0.3s ease-out;
    }

    .loading span {
      width: 8px;
      height: 8px;
      background: var(--gray-60);
      border-radius: 50%;
      display: inline-block;
      animation: bounce 0.8s infinite;
    }

    body.dark .loading span {
      background: var(--gray-80);
    }

    .loading span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .loading span:nth-child(3) {
      animation-delay: 0.4s;
    }

    /* Ensure only one loading indicator at a time */
    .chat-messages .loading+.loading {
      display: none !important;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-6px);
      }
    }

    /* Input Container */
    .input-container {
      background: white;
      border-top: 1px solid var(--gray-20);
      padding: var(--space-l);
      padding-bottom: calc(var(--space-l) + var(--safe-area-bottom));
      display: flex;
      gap: var(--space-s);
      align-items: flex-end;
      z-index: 50;
      min-height: var(--input-container-height);
      backdrop-filter: blur(10px);
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
      flex-shrink: 0;
    }

    @media (min-width: 1024px) {
      .input-container {
        padding: var(--space-l) 10%;
      }
    }

    body.dark .input-container {
      background: #1a1a1a;
      border-top-color: var(--gray-30);
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
    }

    .input-wrapper {
      flex: 1;
      position: relative;
      max-width: 1400px;
      margin: 0 auto;
    }

    .input-field {
      width: 100%;
      padding: 14px 20px;
      border: 2px solid var(--gray-30);
      border-radius: 24px;
      font-size: 15px;
      resize: none;
      outline: none;
      transition: var(--transition);
      background: var(--gray-10);
      min-height: 44px;
      max-height: 120px;
      font-family: inherit;
    }

    body.dark .input-field {
      background: var(--gray-30);
      color: var(--gray-130);
      border-color: var(--gray-40);
    }

    .input-field:focus {
      border-color: var(--primary);
      background: white;
      box-shadow: 0 0 0 4px rgba(116, 39, 116, 0.1);
      transform: translateY(-1px);
    }

    body.dark .input-field:focus {
      background: var(--gray-35);
      box-shadow: 0 0 0 4px rgba(116, 39, 116, 0.2);
    }

    .input-button {
      background: var(--primary);
      color: white;
      border: none;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 18px;
      box-shadow: 0 2px 8px rgba(116, 39, 116, 0.3);
    }

    .input-button:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 20px rgba(116, 39, 116, 0.4);
      background: var(--primary-dark);
    }

    .input-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .input-button.secondary {
      background: var(--gray-30);
      color: var(--gray-80);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .input-button.secondary:hover {
      background: var(--gray-40);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    body.dark .input-button.secondary {
      background: var(--gray-40);
      color: var(--gray-100);
    }

    /* Voice button */
    .voice-button {
      background: linear-gradient(135deg, var(--accent) 0%, #e91e63 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(255, 64, 129, 0.3);
    }

    .voice-button:hover {
      transform: translateY(-2px) scale(1.1);
      box-shadow: 0 6px 20px rgba(255, 64, 129, 0.4);
    }

    .voice-button.active {
      background: var(--error);
      animation: pulse 1.5s infinite;
    }

    /* Image Preview */
    .image-preview-container {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      padding: var(--space-m);
      background: white;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      display: none;
      box-shadow: var(--shadow-medium);
    }

    body.dark .image-preview-container {
      background: var(--gray-30);
    }

    .image-preview-container.active {
      display: block;
      animation: slideUp 0.3s ease-out;
    }

    .image-preview {
      position: relative;
      width: 100px;
      height: 100px;
      border-radius: var(--radius);
      overflow: hidden;
    }

    .image-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .upload-status {
      margin-top: var(--space-s);
      padding: var(--space-xs) var(--space-s);
      background: rgba(116, 39, 116, 0.1);
      border-radius: var(--radius);
      font-size: 13px;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    body.dark .upload-status {
      background: rgba(116, 39, 116, 0.2);
      color: #bb86fc;
    }

    .upload-status i {
      font-size: 14px;
    }

    .image-preview-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: var(--radius-full);
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Float buttons */
    .float-buttons {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 20px);
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 80;
    }

    .fab {
      background: var(--primary);
      color: white;
      border: none;
      width: 56px;
      height: 56px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow-medium);
      font-size: 22px;
    }

    .fab:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-large);
    }

    .fab.secondary {
      background: var(--error);
    }

    .fab.menu {
      background: var(--accent);
    }

    .fab.menu.active {
      transform: rotate(45deg);
    }

    /* Menu Items */
    .menu-items {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 140px);
      right: 20px;
      background: white;
      border-radius: var(--radius);
      box-shadow: var(--shadow-large);
      padding: var(--space-s);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px) scale(0.9);
      transition: var(--transition);
      z-index: 80;
      min-width: 220px;
    }

    body.dark .menu-items {
      background: var(--gray-30);
    }

    .menu-items.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      padding: 12px 16px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
      color: var(--gray-100);
      font-size: 15px;
      font-weight: 500;
    }

    .menu-item:hover {
      background: rgba(var(--primary-rgb), 0.08);
    }

    .menu-item i {
      width: 24px;
      text-align: center;
      color: var(--primary);
    }

    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: var(--space-m);
    }

    .modal.active {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }

    .modal-content {
      background: white;
      border-radius: var(--radius-large);
      box-shadow: var(--shadow-large);
      max-width: 600px;
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
      animation: scaleIn 0.3s ease-out;
      position: relative;
    }

    body.dark .modal-content {
      background: var(--gray-20);
    }

    .modal-header {
      padding: var(--space-l);
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }

    body.dark .modal-header {
      background: var(--gray-20);
    }

    .modal-header h2 {
      font-size: 20px;
      color: var(--gray-100);
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--gray-60);
      cursor: pointer;
      transition: var(--transition);
      padding: 0;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
    }

    .modal-close:hover {
      background: var(--gray-20);
      color: var(--gray-100);
    }

    .modal-body {
      padding: var(--space-l);
    }

    .modal-footer {
      padding: var(--space-l);
      border-top: 1px solid var(--gray-30);
      display: flex;
      justify-content: flex-end;
      gap: var(--space-m);
      position: sticky;
      bottom: 0;
      background: white;
      z-index: 10;
    }

    body.dark .modal-footer {
      background: var(--gray-20);
    }

    .button {
      padding: 10px 20px;
      border-radius: var(--radius);
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      gap: var(--space-s);
    }

    .button-primary {
      background: var(--primary);
      color: white;
    }

    .button-primary:hover {
      background: var(--primary-dark);
    }

    .button-secondary {
      background: var(--gray-20);
      color: var(--gray-100);
    }

    body.dark .button-secondary {
      background: var(--gray-40);
    }

    .button-success {
      background: var(--success);
      color: white;
    }

    .button-success:hover {
      background: #45a049;
    }

    /* Settings */
    .settings-section {
      margin-bottom: var(--space-xl);
      padding-bottom: var(--space-xl);
      border-bottom: 1px solid var(--gray-30);
    }

    .settings-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .settings-section h3 {
      font-size: 18px;
      margin-bottom: var(--space-l);
      color: var(--gray-100);
      font-weight: 600;
    }

    .settings-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-m) 0;
    }

    .settings-item label {
      font-size: 15px;
      color: var(--gray-80);
      font-weight: 500;
    }

    .toggle-switch {
      position: relative;
      width: 48px;
      height: 28px;
      background: var(--gray-30);
      border-radius: var(--radius-full);
      cursor: pointer;
      transition: var(--transition);
    }

    .toggle-switch.active {
      background: var(--success);
    }

    .toggle-switch::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: var(--radius-full);
      transition: var(--transition);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    /* Drop Zone */
    .drop-zone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(var(--primary-rgb), 0.95);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .drop-zone.active {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }

    .drop-zone-content {
      text-align: center;
      color: white;
    }

    .drop-zone-content i {
      font-size: 72px;
      margin-bottom: var(--space-l);
    }

    .drop-zone-content p {
      font-size: 24px;
      font-weight: 600;
    }

    /* Utility Classes */
    .hidden {
      display: none !important;
    }

    .text-center {
      text-align: center;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .message-wrapper {
        max-width: 90%;
      }

      .modal-content {
        margin: 20px;
      }

      /* Mobile header improvements */
      .header {
        padding: 0 var(--space-s);
      }

      .header-left {
        gap: var(--space-s);
        flex: 1;
        min-width: 0;
      }

      .header-title {
        font-size: 16px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .header-actions {
        gap: 4px;
      }

      /* Hide less critical buttons on mobile */
      .header-actions > a[href*="localFirstTools"],
      .header-actions > a[href*="agent_store"],
      .header-actions #collab-os-button,
      .header-actions #archive-chat {
        display: none;
      }

      .header-button {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      /* Make voice indicator more compact */
      .voice-indicator {
        font-size: 12px;
        padding: 4px 8px;
      }

      .voice-indicator span {
        display: none;
      }

      /* Better touch targets for mobile */
      .message-actions button {
        min-width: 44px;
        min-height: 44px;
      }

      .chat-input {
        padding: var(--space-s);
      }

      .input-wrapper {
        gap: var(--space-s);
      }

      /* Split view full screen on mobile */
      .split-view-tool.active {
        width: 100% !important;
      }

      /* Tool gallery better on mobile */
      .tool-gallery-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      }

      .tool-gallery-item {
        padding: var(--space-s);
      }

      .tool-gallery-item-name {
        font-size: 13px;
      }

      .tool-gallery-item-desc {
        font-size: 11px;
      }

      /* Mobile input improvements */
      .input-container {
        padding: var(--space-s);
        padding-bottom: calc(var(--space-s) + var(--safe-area-bottom));
      }

      .input-field {
        font-size: 16px;
        padding: 10px 14px;
      }

      .input-button {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }

      /* Welcome screen adjustments for mobile */
      .chat-messages:empty::before {
        width: 60px;
        height: 60px;
        font-size: 30px;
        border-radius: 15px;
      }

      .chat-messages:empty::after {
        font-size: 16px;
        transform: translate(-50%, calc(-50% + 60px));
        padding: 0 var(--space-m);
        max-width: 280px;
      }

      /* Sidebar full width on mobile */
      .sidebar {
        width: 85%;
        max-width: 320px;
      }

      /* Modal improvements */
      .tool-gallery-modal .tool-gallery-content {
        width: 95%;
        height: 90%;
        margin: 20px auto;
      }
    }

    /* iOS specific fixes */
    @supports (-webkit-touch-callout: none) {
      .app-container {
        height: -webkit-fill-available;
      }
    }

    /* Scrollbar - minimal and elegant */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.15);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.25);
    }

    body.dark ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
    }

    body.dark ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    /* Hide scrollbar until hover (chat area) */
    .chat-messages::-webkit-scrollbar-thumb {
      background: transparent;
    }

    .chat-messages:hover::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.15);
    }

    body.dark .chat-messages:hover::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.15) transparent;
    }

    body.dark * {
      scrollbar-color: rgba(255, 255, 255, 0.15) transparent;
    }

    /* Focus styles */
    *:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Hidden file inputs */
    input[type="file"] {
      display: none;
    }

    /* Split View Styles */
    .split-view-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .split-view-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 300px;
      transition: flex 0.3s ease;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }

    .split-view-divider {
      width: 4px;
      background: var(--gray-30);
      cursor: col-resize;
      position: relative;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    .split-view-divider:hover {
      background: var(--primary);
    }

    .split-view-divider::before {
      content: '';
      position: absolute;
      top: 0;
      left: -4px;
      right: -4px;
      bottom: 0;
    }

    body.dark .split-view-divider {
      background: var(--gray-40);
    }

    .split-view-tool {
      display: none;
      flex-direction: column;
      min-width: 300px;
      background: var(--gray-20);
      transition: flex 0.3s ease;
    }

    .split-view-tool.active {
      display: flex;
      flex: 1;
    }

    body.dark .split-view-tool {
      background: var(--gray-30);
    }

    .split-view-tool-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-m);
      background: var(--gray-30);
      border-bottom: 1px solid var(--gray-40);
    }

    body.dark .split-view-tool-header {
      background: var(--gray-40);
      border-bottom-color: var(--gray-50);
    }

    .split-view-tool-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--gray-100);
      display: flex;
      align-items: center;
      gap: var(--space-s);
    }

    .split-view-tool-actions {
      display: flex;
      gap: var(--space-s);
    }

    .split-view-tool-button {
      background: var(--gray-40);
      border: none;
      color: var(--gray-80);
      width: 28px;
      height: 28px;
      border-radius: var(--radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      font-size: 12px;
    }

    body.dark .split-view-tool-button {
      background: var(--gray-50);
    }

    .split-view-tool-button:hover {
      background: var(--primary);
      color: white;
    }

    .split-view-tool-iframe {
      flex: 1;
      border: none;
      width: 100%;
      background: white;
    }

    body.dark .split-view-tool-iframe {
      background: var(--gray-20);
    }

    /* Tool Gallery Modal */
    .tool-gallery-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      padding: var(--space-l);
    }

    .tool-gallery-modal.active {
      display: flex;
    }

    .tool-gallery-content {
      background: white;
      border-radius: var(--radius-large);
      max-width: 900px;
      width: 100%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: var(--shadow-large);
    }

    body.dark .tool-gallery-content {
      background: var(--gray-20);
    }

    .tool-gallery-header {
      padding: var(--space-l);
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    body.dark .tool-gallery-header {
      border-bottom-color: var(--gray-40);
    }

    .tool-gallery-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--gray-100);
    }

    .tool-gallery-close {
      background: none;
      border: none;
      color: var(--gray-60);
      cursor: pointer;
      font-size: 24px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-small);
      transition: var(--transition);
    }

    .tool-gallery-close:hover {
      background: var(--gray-30);
      color: var(--gray-100);
    }

    .tool-gallery-search {
      padding: var(--space-m) var(--space-l);
      border-bottom: 1px solid var(--gray-30);
    }

    body.dark .tool-gallery-search {
      border-bottom-color: var(--gray-40);
    }

    .tool-gallery-search input {
      width: 100%;
      padding: var(--space-m);
      border: 1px solid var(--gray-30);
      border-radius: var(--radius);
      font-size: 14px;
      background: var(--gray-10);
      color: var(--gray-100);
    }

    body.dark .tool-gallery-search input {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    .tool-gallery-body {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-l);
    }

    .tool-gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: var(--space-m);
    }

    .tool-gallery-item {
      background: var(--gray-10);
      border: 1px solid var(--gray-30);
      border-radius: var(--radius);
      padding: var(--space-m);
      cursor: pointer;
      transition: var(--transition);
    }

    body.dark .tool-gallery-item {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    .tool-gallery-item:hover {
      background: var(--gray-20);
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }

    body.dark .tool-gallery-item:hover {
      background: var(--gray-40);
    }

    .tool-gallery-item-icon {
      width: 48px;
      height: 48px;
      background: var(--primary);
      color: white;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      margin-bottom: var(--space-m);
    }

    .tool-gallery-item-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: var(--space-xs);
    }

    .tool-gallery-item-desc {
      font-size: 13px;
      color: var(--gray-60);
      line-height: 1.4;
    }

    /* Responsive adjustments for split view */
    @media (max-width: 1024px) {
      .split-view-tool.active {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 100;
      }

      .split-view-divider {
        display: none;
      }
    }

    /* ============================================ */
    /* P2P MESH NETWORK STYLES */
    /* ============================================ */

    .mesh-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease;
    }

    .mesh-modal.active {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .mesh-panel {
      background: var(--gray-20);
      border-radius: 16px;
      width: 90%;
      max-width: 1200px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
    }

    body.dark .mesh-panel {
      background: var(--gray-30);
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(40px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .mesh-header {
      padding: 24px;
      border-bottom: 2px solid var(--gray-40);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    body.dark .mesh-header {
      border-bottom-color: var(--gray-50);
    }

    .mesh-title {
      font-size: 24px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--primary);
    }

    .mesh-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--gray-80);
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .mesh-close:hover {
      background: var(--gray-40);
      color: var(--gray-100);
    }

    .mesh-content {
      padding: 24px;
      overflow-y: auto;
      flex: 1;
    }

    .mesh-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .mesh-stat-card {
      background: var(--gray-30);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 2px solid var(--gray-40);
    }

    body.dark .mesh-stat-card {
      background: var(--gray-40);
      border-color: var(--gray-50);
    }

    .mesh-stat-value {
      font-size: 36px;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 8px;
    }

    .mesh-stat-label {
      font-size: 12px;
      color: var(--gray-80);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .mesh-section {
      margin-bottom: 32px;
    }

    .mesh-section-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--gray-100);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mesh-peers {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
    }

    .mesh-peer {
      background: var(--gray-30);
      border: 2px solid var(--gray-40);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 16px;
      transition: all 0.2s ease;
    }

    body.dark .mesh-peer {
      background: var(--gray-40);
      border-color: var(--gray-50);
    }

    .mesh-peer:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .mesh-peer-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
    }

    .mesh-peer-icon.chrome {
      background: linear-gradient(135deg, #4285f4, #34a853);
    }

    .mesh-peer-icon.firefox {
      background: linear-gradient(135deg, #ff7139, #e66000);
    }

    .mesh-peer-icon.safari {
      background: linear-gradient(135deg, #006aff, #0099ff);
    }

    .mesh-peer-icon.edge {
      background: linear-gradient(135deg, #0078d4, #00bcf2);
    }

    .mesh-peer-icon.unknown {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    }

    .mesh-peer-info {
      flex: 1;
      min-width: 0;
    }

    .mesh-peer-name {
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--gray-100);
    }

    .mesh-peer-id {
      font-size: 11px;
      font-family: monospace;
      color: var(--gray-80);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mesh-peer-status {
      font-size: 12px;
      margin-top: 4px;
      color: var(--gray-80);
    }

    .mesh-peer-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .mesh-peer-badge.connected {
      background: rgba(76, 175, 80, 0.15);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .mesh-peer-badge.discovered {
      background: rgba(255, 152, 0, 0.15);
      color: #ff9800;
      border: 1px solid rgba(255, 152, 0, 0.3);
    }

    .mesh-log {
      background: var(--gray-100);
      color: #4caf50;
      border-radius: 12px;
      padding: 16px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }

    body.dark .mesh-log {
      background: var(--gray-20);
    }

    .mesh-log-entry {
      margin-bottom: 8px;
      display: flex;
      gap: 12px;
    }

    .mesh-log-time {
      color: var(--primary);
      flex-shrink: 0;
    }

    .mesh-log-message.success {
      color: #4caf50;
    }

    .mesh-log-message.info {
      color: #2196f3;
    }

    .mesh-log-message.warning {
      color: #ff9800;
    }

    .mesh-log-message.error {
      color: #f44336;
    }

    .mesh-actions {
      display: flex;
      gap: 12px;
      padding: 20px 24px;
      border-top: 2px solid var(--gray-40);
    }

    body.dark .mesh-actions {
      border-top-color: var(--gray-50);
    }

    .mesh-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .mesh-btn-primary {
      background: var(--primary);
      color: white;
    }

    .mesh-btn-primary:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(116, 39, 116, 0.3);
    }

    .mesh-btn-secondary {
      background: var(--gray-40);
      color: var(--gray-100);
    }

    .mesh-btn-secondary:hover {
      background: var(--gray-50);
    }

    .mesh-notification {
      position: fixed;
      top: 80px;
      right: 20px;
      background: white;
      border: 2px solid var(--gray-30);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      z-index: 10001;
      opacity: 0;
      transform: translateX(400px);
      transition: all 0.3s ease;
      max-width: 400px;
    }

    body.dark .mesh-notification {
      background: var(--gray-30);
      border-color: var(--gray-50);
    }

    .mesh-notification.active {
      opacity: 1;
      transform: translateX(0);
    }

    .mesh-notification.success {
      border-left: 4px solid #4caf50;
    }

    .mesh-notification.error {
      border-left: 4px solid #f44336;
    }

    .mesh-notification.info {
      border-left: 4px solid #2196f3;
    }

    .mesh-notification i {
      font-size: 20px;
    }

    .mesh-notification.success i {
      color: #4caf50;
    }

    .mesh-notification.error i {
      color: #f44336;
    }

    .mesh-notification.info i {
      color: #2196f3;
    }

    /* Mesh Status Banner */
    .mesh-status-banner {
      position: fixed;
      top: var(--header-height);
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 16px 20px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      animation: slideDown 0.3s ease;
      gap: 20px;
    }

    .mesh-status-banner.active {
      display: flex;
    }

    .mesh-banner-content {
      display: flex;
      align-items: center;
      gap: 16px;
      flex: 1;
    }

    .mesh-banner-icon {
      font-size: 24px;
      animation: pulse 2s ease-in-out infinite;
    }

    .mesh-banner-text {
      flex: 1;
    }

    .mesh-banner-title {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 4px;
    }

    .mesh-banner-subtitle {
      font-size: 13px;
      opacity: 0.9;
    }

    .mesh-banner-peers {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .mesh-banner-peer-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .mesh-banner-actions {
      display: flex;
      gap: 12px;
    }

    .mesh-banner-btn {
      padding: 8px 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .mesh-banner-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .mesh-banner-close {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s ease;
    }

    .mesh-banner-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Live Sync Indicator */
    .mesh-sync-indicator {
      position: fixed;
      top: calc(var(--header-height) + 10px);
      right: 20px;
      background: #4caf50;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
      animation: slideInRight 0.3s ease;
    }

    .mesh-sync-indicator.active {
      display: flex;
    }

    .mesh-sync-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Mesh Active Indicator on Header Button */
    #mesh-status-btn.mesh-active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      animation: pulseGlow 2s ease-in-out infinite;
    }

    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7);
      }
      50% {
        box-shadow: 0 0 20px 10px rgba(102, 126, 234, 0);
      }
    }

    @media (max-width: 768px) {
      .mesh-panel {
        width: 95%;
        max-height: 95vh;
      }

      .mesh-stats {
        grid-template-columns: repeat(2, 1fr);
      }

      .mesh-peers {
        grid-template-columns: 1fr;
      }

      .mesh-actions {
        flex-direction: column;
      }

      .mesh-notification {
        left: 20px;
        right: 20px;
        max-width: none;
      }
    }
  </style>
</head>

<body>
  <!-- Login Page -->
  <div id="login-page" class="login-container">
    <div class="login-box">
      <div class="login-header">
        <h1>Welcome to RAPP</h1>
        <p>Rapid Agent Prototyping Platform - Sign in to continue</p>
      </div>

      <form id="login-form">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text" id="username" placeholder="Enter your username" required autocomplete="username"
            autocapitalize="off" />
        </div>

        <button type="submit" class="login-button">Sign In</button>
      </form>

      <div class="user-list">
        <h3>Recent Users</h3>
        <div id="recent-users"></div>
      </div>
    </div>
  </div>

  <!-- Main App -->
  <div id="app" class="app-container hidden">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <button class="header-button" id="sidebar-toggle">
          <i class="fas fa-bars"></i>
        </button>
        <h1 class="header-title">
          <span id="current-username">Chat</span>
        </h1>
        <div class="voice-indicator" id="voice-indicator">
          <i class="fas fa-volume-up"></i>
          <span>Speaking...</span>
        </div>
      </div>
      <div class="header-actions">
        <!-- Setup Wizard -->
        <button class="header-button" id="setup-btn" title="Setup Wizard" style="color: var(--warning);">
          <i class="fas fa-magic"></i>
        </button>

        <!-- Chat Management -->
        <button class="header-button" id="archive-chat" title="Archive Chat">
          <i class="fas fa-archive"></i>
        </button>

        <!-- Settings -->
        <button class="header-button" id="theme-toggle" title="Toggle Theme">
          <i class="fas fa-moon"></i>
        </button>
        <button class="header-button" id="logout" title="Sign Out">
          <i class="fas fa-sign-out-alt"></i>
        </button>
      </div>
    </header>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>Chat Library</h2>
        <button class="input-button" id="new-chat">
          <i class="fas fa-plus"></i>
        </button>
      </div>
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="active">Active</button>
        <button class="sidebar-tab" data-tab="archived">Archived</button>
      </div>
      <div class="chat-list" id="chat-list-active"></div>
      <div class="chat-list hidden" id="chat-list-archived"></div>
    </aside>
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <!-- Split View Container -->
    <div class="split-view-container">
      <!-- Main Chat Section -->
      <div class="split-view-main">
        <main class="chat-container">
          <div class="chat-messages-wrapper">
            <div class="chat-messages" id="chat-messages">
              <!-- Welcome Icon (can be replaced with QR code when sharing) -->
              <div id="welcome-icon" class="welcome-icon" style="display: none;">
                <div class="welcome-icon-square" id="robot-icon">
                  <i class="fas fa-robot robot-icon"></i>
                </div>
                <div class="welcome-text">
                  Welcome to RAPP<br>
                  Start a conversation below
                </div>
                <div class="welcome-help" style="margin-top: 32px; max-width: 420px; text-align: left;">
                  <div style="background: linear-gradient(135deg, var(--primary), var(--primary-dark)); border-radius: 16px; padding: 20px 24px; color: white; box-shadow: 0 4px 20px rgba(116, 39, 116, 0.3);">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 14px;">
                      <div style="width: 40px; height: 40px; background: rgba(255,255,255,0.2); border-radius: 10px; display: flex; align-items: center; justify-content: center;">
                        <i class="fas fa-wand-magic-sparkles" style="font-size: 18px;"></i>
                      </div>
                      <div>
                        <div style="font-weight: 600; font-size: 15px;">Need help setting up?</div>
                        <div style="font-size: 13px; opacity: 0.85;">Let an AI agent deploy everything for you</div>
                      </div>
                    </div>
                    <a href="https://github.com/kody-w/rapp-installer" target="_blank" style="display: flex; align-items: center; justify-content: center; gap: 10px; background: white; color: var(--primary-dark); padding: 14px 20px; border-radius: 10px; font-weight: 600; font-size: 14px; text-decoration: none; margin-bottom: 12px; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';" onmouseout="this.style.transform=''; this.style.boxShadow='';">
                      <i class="fab fa-github" style="font-size: 18px;"></i>
                      Open Installer Guide
                      <i class="fas fa-arrow-right" style="font-size: 12px; opacity: 0.7;"></i>
                    </a>
                    <div style="background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border-radius: 10px; padding: 12px 14px; display: flex; align-items: center; gap: 10px; cursor: pointer; transition: background 0.2s;" onclick="copySkillLink(this)" onmouseover="this.style.background='rgba(255,255,255,0.25)'" onmouseout="this.style.background='rgba(255,255,255,0.15)'">
                      <i class="fas fa-link" style="font-size: 14px; opacity: 0.8; flex-shrink: 0;"></i>
                      <code style="flex: 1; font-size: 12px; opacity: 0.95; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">rapp-installer/main/skill.md</code>
                      <div style="background: rgba(255,255,255,0.2); padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 6px; flex-shrink: 0;">
                        <i class="fas fa-copy"></i> Copy
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <!-- Loading Indicator will be appended here dynamically -->
            </div>
          </div>
        </main>

        <!-- Input Container -->
    <div class="input-container" id="input-container">
      <button class="input-button secondary" id="upload-image">
        <i class="fas fa-image"></i>
      </button>
      <button class="input-button voice-button" id="voice-toggle">
        <i class="fas fa-microphone"></i>
      </button>
      <div class="input-wrapper">
        <div class="mention-dropdown" id="mention-dropdown"></div>
        <div class="image-preview-container" id="image-preview-container"></div>
        <textarea class="input-field" id="user-input" placeholder="Type a message or @mention an endpoint..." rows="1"></textarea>
      </div>
      <button class="input-button" id="send-button">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
      </div>
      <!-- End Main Chat Section -->

      <!-- Split View Divider -->
      <div class="split-view-divider" id="split-view-divider"></div>

      <!-- Split View Tool Panel -->
      <div class="split-view-tool" id="split-view-tool">
        <div class="split-view-tool-header">
          <div class="split-view-tool-title">
            <i class="fas fa-cube"></i>
            <span id="split-view-tool-name">Tool</span>
          </div>
          <div class="split-view-tool-actions">
            <button class="split-view-tool-button" id="split-view-fullscreen" title="Toggle Fullscreen">
              <i class="fas fa-expand"></i>
            </button>
            <button class="split-view-tool-button" id="split-view-refresh" title="Refresh Tool">
              <i class="fas fa-sync-alt"></i>
            </button>
            <button class="split-view-tool-button" id="split-view-close" title="Close Tool">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <iframe class="split-view-tool-iframe" id="split-view-tool-iframe" sandbox="allow-scripts allow-same-origin allow-forms"></iframe>
      </div>
    </div>
    <!-- End Split View Container -->

    <!-- Float Buttons -->
    <div class="float-buttons">
      <button class="fab secondary" id="clear-chat">
        <i class="fas fa-trash"></i>
      </button>
      <button class="fab menu" id="menu-toggle">
        <i class="fas fa-plus"></i>
      </button>
    </div>

    <!-- Menu Items -->
    <div class="menu-items" id="menu-items">
      <div class="menu-item" id="export-chat">
        <i class="fas fa-download"></i>
        <span>Export Chat</span>
      </div>
      <div class="menu-item" id="import-chat">
        <i class="fas fa-upload"></i>
        <span>Import Chat</span>
      </div>
      <div class="menu-item" id="export-all">
        <i class="fas fa-file-archive"></i>
        <span>Export All Data</span>
      </div>
      <div class="menu-item" id="import-all">
        <i class="fas fa-file-import"></i>
        <span>Import Data</span>
      </div>
      <div class="menu-item" id="time-machine">
        <i class="fas fa-history"></i>
        <span>Time Machine</span>
      </div>
      <div class="menu-item" id="settings">
        <i class="fas fa-cog"></i>
        <span>Settings</span>
      </div>
    </div>

    <!-- Drop Zone -->
    <div class="drop-zone" id="drop-zone">
      <div class="drop-zone-content">
        <i class="fas fa-cloud-upload-alt"></i>
        <p>Drop files here to import</p>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settings-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Settings</h2>
        <button class="modal-close" id="settings-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <!-- RAPPID Settings Backup -->
        <div style="margin-bottom: var(--space-m); padding: var(--space-m); background: var(--gray-10); border-radius: var(--radius); border-left: 3px solid var(--primary);">
          <p style="margin: 0; font-size: 0.9em; color: var(--text-secondary);">
            <strong>RAPPID Backup:</strong> Save your endpoints, API keys, and voice settings locally for safekeeping. Import them back anytime to restore your configuration.
          </p>
        </div>
        <div class="settings-import-export">
          <button class="button button-secondary" id="export-settings" title="Download RAPPID configuration to local file">
            <i class="fas fa-download"></i>
            Export RAPPID Backup
          </button>
          <button class="button button-secondary" id="import-settings" title="Restore RAPPID configuration from local file">
            <i class="fas fa-upload"></i>
            Import RAPPID Backup
          </button>
        </div>

        <div class="settings-section">
          <h3>Appearance</h3>
          <div class="settings-item">
            <label for="dark-mode-toggle">Dark Mode</label>
            <div class="toggle-switch" id="dark-mode-toggle"></div>
          </div>
        </div>
        <div class="settings-section">
          <h3>Sound & Voice</h3>
          <div class="settings-item">
            <label for="sound-toggle">Enable Sound Effects</label>
            <div class="toggle-switch" id="sound-toggle"></div>
          </div>
          <div class="settings-item">
            <label for="voice-enabled-toggle">Enable Voice Response</label>
            <div class="toggle-switch" id="voice-enabled-toggle"></div>
          </div>
          <div class="settings-item">
            <label for="auto-speak-toggle">Auto-speak Responses</label>
            <div class="toggle-switch" id="auto-speak-toggle"></div>
          </div>
          <div class="form-group" style="margin-top: 16px">
            <label for="azure-tts-key">Azure Speech API Key (TTS & STT)</label>
            <input type="password" id="azure-tts-key" placeholder="Enter your Azure Speech Services API key" />
            <small style="color: var(--gray-80); font-size: 12px; margin-top: 4px; display: block;">
              Used for both text-to-speech output and speech-to-text microphone input
            </small>
          </div>
          <div class="form-group">
            <label for="azure-region-select">Azure Region</label>
            <select id="azure-region-select" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--gray-40);
                  border-radius: 4px;
                ">
              <option value="eastus">East US</option>
              <option value="eastus2" selected>East US 2</option>
              <option value="westus">West US</option>
              <option value="westus2">West US 2</option>
              <option value="centralus">Central US</option>
              <option value="northeurope">North Europe</option>
              <option value="westeurope">West Europe</option>
              <option value="southeastasia">Southeast Asia</option>
              <option value="australiaeast">Australia East</option>
              <option value="uksouth">UK South</option>
            </select>
            <small style="color: var(--gray-80); font-size: 12px; margin-top: 4px; display: block;">
              Must match your Azure Speech Services resource region
            </small>
          </div>
          <div class="form-group">
            <label for="tts-voice-select">TTS Voice</label>
            <select id="tts-voice-select" style="
                  width: 100%;
                  padding: 8px;
                  border: 1px solid var(--gray-40);
                  border-radius: 4px;
                ">
              <option value="en-US-JennyNeural">Jenny (Female)</option>
              <option value="en-US-GuyNeural">Guy (Male)</option>
              <option value="en-US-AriaNeural">Aria (Female)</option>
              <option value="en-US-DavisNeural">Davis (Male)</option>
              <option value="en-US-AmberNeural">Amber (Female)</option>
              <option value="en-US-JasonNeural">Jason (Male)</option>
              <option value="en-GB-SoniaNeural">
                Sonia (British Female)
              </option>
              <option value="en-GB-RyanNeural">Ryan (British Male)</option>
            </select>
          </div>
        </div>
        <div class="settings-section">
          <h3>API Endpoints</h3>
          <div class="endpoint-list" id="endpoint-list"></div>
          <button class="button button-primary" id="add-endpoint" style="width: 100%; margin-top: 16px;">
            <i class="fas fa-plus"></i>
            Add Endpoint
          </button>
        </div>
        <div class="settings-section">
          <h3>Data Management</h3>
          <button class="button button-secondary" id="clear-all-data">
            <i class="fas fa-trash-alt"></i>
            Clear All Data
          </button>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button button-secondary" id="cancel-settings">
          Cancel
        </button>
        <button class="button button-success" id="save-all-settings">
          <i class="fas fa-save"></i>
          Save Settings
        </button>
      </div>
    </div>
  </div>

  <!-- Onboarding Wizard Modal -->
  <div class="modal" id="onboarding-modal">
    <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-header" style="border-bottom: none; padding-bottom: 0;">
        <h2 style="display: flex; align-items: center; gap: 12px;">
          <span style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: white;">
            <i class="fas fa-rocket"></i>
          </span>
          Welcome to RAPP
        </h2>
        <button class="modal-close" id="onboarding-close"><i class="fas fa-times"></i></button>
      </div>
      <div class="modal-body" style="padding-top: 12px;">
        <p style="color: var(--gray-80); margin-bottom: 24px; font-size: 16px;">
          Rapid Agent Prototyping Platform - Build and deploy AI agents in minutes.
        </p>

        <!-- Step Indicator -->
        <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 32px;" id="onboarding-steps">
          <div class="onboarding-step active" data-step="1">
            <span class="step-number">1</span>
            <span class="step-label">Choose Path</span>
          </div>
          <div class="onboarding-connector"></div>
          <div class="onboarding-step" data-step="2">
            <span class="step-number">2</span>
            <span class="step-label">Deploy</span>
          </div>
          <div class="onboarding-connector"></div>
          <div class="onboarding-step" data-step="3">
            <span class="step-number">3</span>
            <span class="step-label">Connect</span>
          </div>
        </div>

        <!-- Step 1: Choose Path -->
        <div class="onboarding-panel active" data-panel="1">
          <h3 style="margin-bottom: 20px; text-align: center;">How would you like to get started?</h3>
          
          <div style="display: grid; gap: 16px;">
            <!-- Option A: AI Agent Setup (Recommended) -->
            <div class="setup-option" data-option="copilot" style="border: 2px solid var(--gray-30); border-radius: var(--radius); padding: 20px; cursor: pointer; transition: all 0.2s;">
              <div style="display: flex; align-items: flex-start; gap: 16px;">
                <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #6e40c9, #8957e5); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 20px; flex-shrink: 0;">
                  <i class="fas fa-robot"></i>
                </div>
                <div style="flex: 1;">
                  <h4 style="margin-bottom: 4px; display: flex; align-items: center; gap: 8px;">
                    Let an AI Agent Set It Up
                    <span style="background: var(--success); color: white; font-size: 10px; padding: 2px 8px; border-radius: 10px; font-weight: 600;">RECOMMENDED</span>
                  </h4>
                  <p style="color: var(--gray-80); font-size: 14px; margin-bottom: 8px;">
                    Give this skill link to any AI agent and it will deploy everything for you.
                  </p>
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Fully Automated</span>
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Generates RAPPid.json</span>
                  </div>
                </div>
                <i class="fas fa-chevron-right" style="color: var(--gray-60);"></i>
              </div>
            </div>

            <!-- Option B: One-Click Azure Deploy (Advanced) -->
            <div class="setup-option" data-option="azure" style="border: 2px solid var(--gray-30); border-radius: var(--radius); padding: 20px; cursor: pointer; transition: all 0.2s;">
              <div style="display: flex; align-items: flex-start; gap: 16px;">
                <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #0078d4, #00bcf2); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 20px; flex-shrink: 0;">
                  <i class="fab fa-microsoft"></i>
                </div>
                <div style="flex: 1;">
                  <h4 style="margin-bottom: 4px; display: flex; align-items: center; gap: 8px;">
                    One-Click Azure Deploy
                    <span style="background: var(--gray-20); color: var(--gray-80); font-size: 10px; padding: 2px 8px; border-radius: 10px; font-weight: 600;">ADVANCED</span>
                  </h4>
                  <p style="color: var(--gray-80); font-size: 14px; margin-bottom: 8px;">
                    Deploy Azure resources via ARM template, then manually clone and deploy the code.
                  </p>
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Azure OpenAI</span>
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Function App</span>
                  </div>
                </div>
                <i class="fas fa-chevron-right" style="color: var(--gray-60);"></i>
              </div>
            </div>

            <!-- Option C: Already Have Endpoint -->
            <div class="setup-option" data-option="existing" style="border: 2px solid var(--gray-30); border-radius: var(--radius); padding: 20px; cursor: pointer; transition: all 0.2s;">
              <div style="display: flex; align-items: flex-start; gap: 16px;">
                <div style="width: 48px; height: 48px; background: linear-gradient(135deg, var(--success), #2e7d32); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 20px; flex-shrink: 0;">
                  <i class="fas fa-plug"></i>
                </div>
                <div style="flex: 1;">
                  <h4 style="margin-bottom: 4px;">I Already Have an Endpoint</h4>
                  <p style="color: var(--gray-80); font-size: 14px; margin-bottom: 8px;">
                    Connect to an existing RAPP backend or import a RAPPid.json configuration file.
                  </p>
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Quick Connect</span>
                    <span style="background: var(--gray-20); padding: 4px 8px; border-radius: 4px; font-size: 12px;">Import Config</span>
                  </div>
                </div>
                <i class="fas fa-chevron-right" style="color: var(--gray-60);"></i>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 2A: Azure Deploy -->
        <div class="onboarding-panel" data-panel="2-azure">
          <div style="text-align: center; margin-bottom: 24px;">
            <div style="width: 80px; height: 80px; background: linear-gradient(135deg, #0078d4, #00bcf2); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px; font-size: 36px; color: white;">
              <i class="fab fa-microsoft"></i>
            </div>
            <h3>Deploy to Azure</h3>
            <p style="color: var(--gray-80);">Click the button below to deploy all required resources</p>
          </div>

          <div style="background: var(--gray-20); border-radius: var(--radius); padding: 24px; margin-bottom: 20px; text-align: center;">
            <a href="https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fraw.githubusercontent.com%2Fkody-w%2Frapp-installer%2Frefs%2Fheads%2Fmain%2Fazuredeploy.json" 
               target="_blank"
               class="button button-primary"
               style="font-size: 18px; padding: 16px 32px; text-decoration: none; display: inline-flex; align-items: center; gap: 12px;">
              <img src="https://aka.ms/deploytoazurebutton" alt="Deploy to Azure" style="height: 28px;">
            </a>
            <p style="color: var(--gray-60); font-size: 13px; margin-top: 16px;">
              Opens Azure Portal with pre-configured template
            </p>
          </div>

          <div style="background: var(--gray-20); border-radius: var(--radius); padding: 20px;">
            <h4 style="margin-bottom: 12px;"><i class="fas fa-list-check" style="color: var(--primary); margin-right: 8px;"></i>After deployment completes:</h4>
            <ol style="color: var(--gray-80); padding-left: 20px; line-height: 2;">
              <li>Copy the <strong>functionAppName</strong> from deployment outputs</li>
              <li>Clone the repo and deploy code</li>
              <li>Get your function key from Azure Portal</li>
              <li>Come back here and click "Connect Endpoint"</li>
            </ol>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button class="button button-secondary" onclick="showOnboardingStep('1')" style="flex: 1;"><i class="fas fa-arrow-left"></i> Back</button>
            <button class="button button-primary" onclick="showOnboardingStep('3')" style="flex: 1;">Connect Endpoint <i class="fas fa-arrow-right"></i></button>
          </div>
        </div>

        <!-- Step 2B: AI Agent Setup -->
        <div class="onboarding-panel" data-panel="2-copilot">
          <div style="text-align: center; margin-bottom: 24px;">
            <div style="width: 80px; height: 80px; background: linear-gradient(135deg, #6e40c9, #8957e5); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px; font-size: 36px; color: white;">
              <i class="fas fa-robot"></i>
            </div>
            <h3>Give This Link to Any AI Agent</h3>
            <p style="color: var(--gray-80);">Copy the skill link and paste it into your favorite AI assistant</p>
          </div>

          <div style="background: var(--gray-20); border-radius: var(--radius); padding: 20px; margin-bottom: 20px;">
            <h4 style="margin-bottom: 12px;"><i class="fas fa-link" style="color: var(--primary); margin-right: 8px;"></i>Skill Link:</h4>
            <div style="background: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 8px; font-family: 'Monaco', 'Menlo', monospace; font-size: 13px; position: relative; word-break: break-all;">
              <code>https://raw.githubusercontent.com/kody-w/rapp-installer/main/skill.md</code>
              <button onclick="copyOnboardingSkillLink(this)" 
                      style="position: absolute; top: 8px; right: 8px; background: #333; border: none; color: #888; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                <i class="fas fa-copy"></i>
              </button>
            </div>
          </div>

          <div style="background: linear-gradient(135deg, rgba(116, 39, 116, 0.1), rgba(116, 39, 116, 0.05)); border: 1px solid rgba(116, 39, 116, 0.2); border-radius: var(--radius); padding: 20px;">
            <h4 style="margin-bottom: 12px;"><i class="fas fa-magic" style="color: var(--primary); margin-right: 8px;"></i>The agent will:</h4>
            <ul style="color: var(--gray-80); padding-left: 20px; line-height: 2;">
              <li>Clone the RAPP repository</li>
              <li>Check and install prerequisites</li>
              <li>Create Azure resources (OpenAI, Storage, Function App)</li>
              <li>Configure authentication and RBAC roles</li>
              <li>Deploy the function and generate <strong>RAPPid.json</strong></li>
            </ul>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button class="button button-secondary" onclick="showOnboardingStep('1')" style="flex: 1;"><i class="fas fa-arrow-left"></i> Back</button>
            <button class="button button-primary" onclick="showOnboardingStep('3')" style="flex: 1;">Connect Endpoint <i class="fas fa-arrow-right"></i></button>
          </div>
        </div>

        <!-- Step 3: Connect Endpoint -->
        <div class="onboarding-panel" data-panel="3">
          <div style="text-align: center; margin-bottom: 24px;">
            <div style="width: 80px; height: 80px; background: linear-gradient(135deg, var(--success), #2e7d32); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px; font-size: 36px; color: white;">
              <i class="fas fa-plug"></i>
            </div>
            <h3>Connect Your Endpoint</h3>
            <p style="color: var(--gray-80);">Import a config file or enter your endpoint details manually</p>
          </div>

          <!-- Import Option -->
          <div style="background: var(--gray-20); border-radius: var(--radius); padding: 24px; margin-bottom: 20px; text-align: center; border: 2px dashed var(--gray-40);" id="import-drop-zone">
            <i class="fas fa-file-import" style="font-size: 32px; color: var(--primary); margin-bottom: 12px;"></i>
            <h4 style="margin-bottom: 8px;">Import RAPPid.json</h4>
            <p style="color: var(--gray-80); font-size: 14px; margin-bottom: 16px;">
              Drag & drop your config file here, or click to browse
            </p>
            <input type="file" id="onboarding-import-input" accept=".json" hidden>
            <button class="button button-primary" onclick="document.getElementById('onboarding-import-input').click()">
              <i class="fas fa-folder-open"></i> Choose File
            </button>
          </div>

          <div style="display: flex; align-items: center; gap: 16px; margin: 24px 0;">
            <div style="flex: 1; height: 1px; background: var(--gray-40);"></div>
            <span style="color: var(--gray-60); font-size: 14px;">OR</span>
            <div style="flex: 1; height: 1px; background: var(--gray-40);"></div>
          </div>

          <!-- Manual Entry -->
          <div style="background: var(--gray-20); border-radius: var(--radius); padding: 20px;">
            <h4 style="margin-bottom: 16px;"><i class="fas fa-keyboard" style="color: var(--primary); margin-right: 8px;"></i>Enter Manually</h4>
            <div class="form-group" style="margin-bottom: 16px;">
              <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 14px;">Endpoint Name</label>
              <input type="text" id="onboarding-endpoint-name" placeholder="e.g., My RAPP Agent" style="width: 100%; padding: 12px; border: 2px solid var(--gray-30); border-radius: 8px; font-size: 14px; background: var(--gray-10);">
            </div>
            <div class="form-group" style="margin-bottom: 16px;">
              <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 14px;">Azure Function URL</label>
              <input type="text" id="onboarding-endpoint-url" placeholder="https://your-function.azurewebsites.net/api/businessinsightbot_function" style="width: 100%; padding: 12px; border: 2px solid var(--gray-30); border-radius: 8px; font-size: 14px; background: var(--gray-10);">
            </div>
            <div class="form-group" style="margin-bottom: 0;">
              <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 14px;">Function Key</label>
              <input type="password" id="onboarding-endpoint-key" placeholder="Your function key" style="width: 100%; padding: 12px; border: 2px solid var(--gray-30); border-radius: 8px; font-size: 14px; background: var(--gray-10);">
            </div>
          </div>

          <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button class="button button-secondary" onclick="showOnboardingStep('1')" style="flex: 1;"><i class="fas fa-arrow-left"></i> Back</button>
            <button class="button button-primary" id="onboarding-save-endpoint" style="flex: 1;"><i class="fas fa-check"></i> Save & Start Chatting</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    .setup-option:hover { border-color: var(--primary) !important; background: rgba(116, 39, 116, 0.03); }
    .setup-option.selected { border-color: var(--primary) !important; background: rgba(116, 39, 116, 0.08); }
    .onboarding-panel { display: none; }
    .onboarding-panel.active { display: block; }
    .onboarding-step { display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0.5; transition: opacity 0.2s; }
    .onboarding-step.active { opacity: 1; }
    .onboarding-step.completed { opacity: 1; }
    .onboarding-step .step-number { 
      width: 32px; height: 32px; border-radius: 50%; 
      background: var(--gray-30); color: var(--gray-60);
      display: flex; align-items: center; justify-content: center;
      font-weight: 600; font-size: 14px; transition: all 0.2s;
    }
    .onboarding-step.active .step-number { background: var(--primary); color: white; }
    .onboarding-step.completed .step-number { background: var(--success); color: white; }
    .onboarding-step .step-label { font-size: 12px; color: var(--gray-60); }
    .onboarding-step.active .step-label { color: var(--gray-100); font-weight: 600; }
    .onboarding-connector { width: 60px; height: 2px; background: var(--gray-30); margin-top: 16px; }
    #import-drop-zone.dragover { border-color: var(--primary) !important; background: rgba(116, 39, 116, 0.05); }
  </style>

  <!-- Endpoint Modal -->
  <div class="modal" id="endpoint-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="endpoint-modal-title">Add Endpoint</h2>
        <button class="modal-close" id="endpoint-modal-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="endpoint-name">Endpoint Name</label>
          <input type="text" id="endpoint-name" placeholder="e.g., Production Bot" />
        </div>
        <div class="form-group">
          <label for="endpoint-url">Azure Function URL</label>
          <input type="text" id="endpoint-url" placeholder="https://your-function.azurewebsites.net/api/..." />
        </div>
        <div class="form-group">
          <label for="endpoint-key">Function Key</label>
          <input type="text" id="endpoint-key" placeholder="Your function key" />
        </div>
        <div class="form-group">
          <label for="endpoint-guid">User GUID</label>
          <input type="text" id="endpoint-guid" placeholder="c0p110t0-aaaa-bbbb-cccc-123456789abc" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="button button-secondary" id="cancel-endpoint">
          Cancel
        </button>
        <button class="button button-success" id="save-endpoint">
          <i class="fas fa-save"></i>
          Save Endpoint
        </button>
      </div>
    </div>
  </div>

  <!-- Time Machine Modal -->
  <div class="modal" id="time-machine-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Time Machine</h2>
        <button class="modal-close" id="time-machine-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="text-center">
          <p>Replay the current conversation</p>
        </div>
        <div class="text-center">
          <button class="button button-primary" id="time-machine-start">
            <i class="fas fa-play"></i> Start Replay
          </button>
        </div>
        <div class="hidden" id="time-machine-controls">
          <div class="text-center">
            <span id="time-machine-progress">0 / 0</span>
          </div>
          <div class="text-center" style="margin-top: 20px;">
            <button class="button button-secondary" id="time-machine-prev">
              <i class="fas fa-step-backward"></i>
            </button>
            <button class="button button-primary" id="time-machine-play">
              <i class="fas fa-play"></i>
            </button>
            <button class="button button-secondary" id="time-machine-next">
              <i class="fas fa-step-forward"></i>
            </button>
            <button class="button button-secondary" id="time-machine-stop">
              <i class="fas fa-stop"></i>
            </button>
          </div>
          <div class="text-center" style="margin-top: 20px;">
            <button class="button button-success" id="time-machine-branch">
              <i class="fas fa-code-branch"></i> Continue from Here
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Live Order Taking Modal -->
  <div class="modal" id="live-order-modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h2> Live Order Taking</h2>
        <button class="modal-close" id="live-order-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
        <!-- Status indicator -->
        <div style="text-align: center; margin-bottom: 20px;">
          <div id="live-order-status" style="display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: var(--success); color: white; border-radius: 20px; font-weight: 500;">
            <i class="fas fa-microphone" style="animation: pulse 1.5s ease-in-out infinite;"></i>
            <span>Listening...</span>
          </div>
        </div>

        <!-- Live Transcript -->
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--gray-100); font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">
            <i class="fas fa-comment-dots"></i> Live Transcript
          </h3>
          <div id="live-order-transcript" style="background: var(--gray-20); padding: 16px; border-radius: var(--radius); min-height: 80px; font-family: monospace; font-size: 14px; line-height: 1.6; border-left: 4px solid var(--primary);">
            <span style="color: var(--gray-80); font-style: italic;">Start speaking to place your order...</span>
          </div>
        </div>

        <!-- Agent Feedback -->
        <div style="margin-bottom: 24px;">
          <h3 style="margin-bottom: 12px; color: var(--gray-100); font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">
            <i class="fas fa-robot"></i> AI Assistant Feedback
          </h3>
          <div id="live-order-feedback" style="background: var(--gray-20); padding: 16px; border-radius: var(--radius); min-height: 60px; border-left: 4px solid var(--info);">
            <span style="color: var(--gray-80); font-style: italic;">Waiting for order input...</span>
          </div>
        </div>

        <!-- Current Order Summary -->
        <div>
          <h3 style="margin-bottom: 12px; color: var(--gray-100); font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">
            <i class="fas fa-receipt"></i> Order Summary
          </h3>
          <div id="live-order-summary" style="background: var(--gray-20); padding: 16px; border-radius: var(--radius); min-height: 100px; border-left: 4px solid var(--warning);">
            <div style="color: var(--gray-80); font-style: italic;">No items yet...</div>
          </div>
          <div style="margin-top: 12px; text-align: right;">
            <strong style="font-size: 18px; color: var(--primary);">Total: $<span id="live-order-total">0.00</span></strong>
          </div>
        </div>
      </div>
      <div class="modal-footer" style="display: flex; gap: 12px; justify-content: flex-end;">
        <button class="button button-secondary" id="live-order-cancel">
          <i class="fas fa-times"></i> Cancel Order
        </button>
        <button class="button button-success" id="live-order-confirm">
          <i class="fas fa-check"></i> Confirm Order
        </button>
      </div>
    </div>
  </div>

  <!-- Tool Gallery Modal -->
  <div class="tool-gallery-modal" id="tool-gallery-modal">
    <div class="tool-gallery-content">
      <div class="tool-gallery-header">
        <h2 class="tool-gallery-title">Select a Tool to Pin</h2>
        <button class="tool-gallery-close" id="tool-gallery-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="tool-gallery-search">
        <input type="text" id="tool-gallery-search-input" placeholder="Search tools...">
      </div>
      <div class="tool-gallery-body">
        <div class="tool-gallery-grid" id="tool-gallery-grid">
          <!-- Tools will be dynamically loaded here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input type="file" id="image-upload-input" accept="image/*" />
  <input type="file" id="chat-import-input" accept=".json" />
  <input type="file" id="data-import-input" accept=".json" />
  <input type="file" id="settings-import-input" accept=".json" />

  <!-- P2P Mesh Network Modal -->
  <div id="mesh-modal" class="mesh-modal">
    <div class="mesh-panel">
      <div class="mesh-header">
        <div class="mesh-title">
          <i class="fas fa-project-diagram"></i>
          Distributed P2P Mesh Network
        </div>
        <button class="mesh-close" id="mesh-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <div class="mesh-content">
        <div class="mesh-stats">
          <div class="mesh-stat-card">
            <div class="mesh-stat-value" id="mesh-connected-count">0</div>
            <div class="mesh-stat-label">Connected Browsers</div>
          </div>
          <div class="mesh-stat-card">
            <div class="mesh-stat-value" id="mesh-operation-count">0</div>
            <div class="mesh-stat-label">Operations Synced</div>
          </div>
          <div class="mesh-stat-card">
            <div class="mesh-stat-value" id="mesh-sync-count">0</div>
            <div class="mesh-stat-label">State Synchronizations</div>
          </div>
          <div class="mesh-stat-card">
            <div class="mesh-stat-value" id="mesh-node-browser">-</div>
            <div class="mesh-stat-label">This Browser</div>
          </div>
        </div>

        <div class="mesh-section">
          <div class="mesh-section-title">
            <i class="fas fa-users"></i>
            Connected Browsers (<span id="mesh-peer-list-count">0</span>)
          </div>
          <div class="mesh-peers" id="mesh-peer-list">
            <div style="text-align: center; padding: 40px; color: var(--gray-80); grid-column: 1 / -1;">
              <i class="fas fa-info-circle" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></i>
              <p>No other browsers detected yet.</p>
              <p style="margin-top: 8px; font-size: 14px;">Open RAPP in Chrome, Firefox, Safari, or Edge to form a mesh network!</p>
            </div>
          </div>
        </div>

        <div class="mesh-section">
          <div class="mesh-section-title">
            <i class="fas fa-terminal"></i>
            Activity Log
          </div>
          <div class="mesh-log" id="mesh-activity-log">
            <div class="mesh-log-entry">
              <div class="mesh-log-time">[--:--:--]</div>
              <div class="mesh-log-message info">Initializing P2P mesh network...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="mesh-actions">
        <button class="mesh-btn mesh-btn-primary" id="mesh-open-new-window">
          <i class="fas fa-window-restore"></i>
          Open in New Browser Window
        </button>
        <button class="mesh-btn mesh-btn-secondary" id="mesh-force-sync">
          <i class="fas fa-sync"></i>
          Force Sync Now
        </button>
      </div>
    </div>
  </div>

  <!-- Mesh Status Banner -->
  <div id="mesh-status-banner" class="mesh-status-banner">
    <div class="mesh-banner-content">
      <div class="mesh-banner-icon"></div>
      <div class="mesh-banner-text">
        <div class="mesh-banner-title">P2P Mesh Network Active!</div>
        <div class="mesh-banner-subtitle" id="mesh-banner-subtitle">Connected to <span id="mesh-banner-count">0</span> browser(s)</div>
      </div>
      <div class="mesh-banner-peers" id="mesh-banner-peers"></div>
    </div>
    <div class="mesh-banner-actions">
      <button class="mesh-banner-btn" id="mesh-banner-test"> Test Sync</button>
      <button class="mesh-banner-btn" id="mesh-banner-share"> Share (QR Code)</button>
      <button class="mesh-banner-btn" id="mesh-banner-view"> View Details</button>
    </div>
    <button class="mesh-banner-close" id="mesh-banner-close">
      <i class="fas fa-times"></i>
    </button>
  </div>

  <!-- Live Sync Indicator -->
  <div id="mesh-sync-indicator" class="mesh-sync-indicator">
    <div class="mesh-sync-spinner"></div>
    <span>Syncing...</span>
  </div>

  <!-- Show Mode Modal (Cross-Device Sharing) -->
  <div id="show-mode-modal" class="mesh-modal" style="display: none;">
    <div class="mesh-panel" style="max-width: 500px;">
      <div class="mesh-header">
        <div class="mesh-panel-icon">
          <i class="fas fa-qrcode"></i>
        </div>
        <div class="mesh-panel-title">
          Share RAPP Across Devices
        </div>
        <button class="mesh-close" id="show-mode-close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <div class="mesh-content" style="text-align: center;">
        <p style="margin-bottom: 20px; color: var(--gray-80);">
          Scan this QR code on another device to sync your RAPP state in real-time!
        </p>

        <div id="show-mode-status" style="padding: 12px; background: rgba(76, 175, 80, 0.1); border-radius: var(--radius); margin-bottom: 20px; display: none;">
          <div style="display: flex; align-items: center; justify-content: center; gap: 10px; color: #4caf50;">
            <i class="fas fa-broadcast-tower"></i>
            <span>Broadcasting - <span id="show-mode-viewer-count">0</span> device(s) connected</span>
          </div>
        </div>

        <div id="qr-code-container" style="display: inline-block; padding: 20px; background: white; border-radius: var(--radius); margin: 20px 0;">
          <canvas id="qr-code-canvas"></canvas>
        </div>

        <div style="margin: 20px 0;">
          <input type="text" id="share-url" readonly
            style="width: 100%; padding: 12px; background: var(--gray-20); border: 1px solid var(--gray-40); border-radius: var(--radius); font-family: monospace; font-size: 12px; text-align: center;"
            value="Generating share link...">
        </div>

        <button class="mesh-btn mesh-btn-primary" id="copy-share-url" style="width: 100%;">
          <i class="fas fa-copy"></i>
          Copy Share Link
        </button>

        <p style="margin-top: 20px; font-size: 12px; color: var(--gray-80);">
           Other devices will follow your RAPP state updates in real-time via P2P connection
        </p>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <script>
    // Copy skill link helper function
    function copySkillLink(element) {
      const skillUrl = 'https://raw.githubusercontent.com/kody-w/rapp-installer/main/skill.md';
      navigator.clipboard.writeText(skillUrl).then(() => {
        const copyBtn = element.querySelector('div:last-child');
        const originalText = copyBtn.innerHTML;
        copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
        copyBtn.style.background = 'rgba(76, 175, 80, 0.4)';
        setTimeout(() => {
          copyBtn.innerHTML = originalText;
          copyBtn.style.background = 'rgba(255,255,255,0.2)';
        }, 2000);
      });
    }

    // Copy skill link for onboarding modal
    function copyOnboardingSkillLink(button) {
      const skillUrl = 'https://raw.githubusercontent.com/kody-w/rapp-installer/main/skill.md';
      navigator.clipboard.writeText(skillUrl).then(() => {
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.style.background = '#4caf50';
        button.style.color = 'white';
        setTimeout(() => {
          button.innerHTML = '<i class="fas fa-copy"></i>';
          button.style.background = '#333';
          button.style.color = '#888';
        }, 2000);
      });
    }

    // Onboarding wizard functions
    function showOnboardingStep(step) {
      // Hide all panels
      document.querySelectorAll('.onboarding-panel').forEach(p => p.classList.remove('active'));
      // Show target panel
      const targetPanel = document.querySelector(`.onboarding-panel[data-panel="${step}"]`);
      if (targetPanel) targetPanel.classList.add('active');
      
      // Update step indicators
      const stepNum = parseInt(step) || parseInt(step.split('-')[0]);
      document.querySelectorAll('.onboarding-step').forEach(s => {
        const sNum = parseInt(s.dataset.step);
        s.classList.remove('active', 'completed');
        if (sNum < stepNum) s.classList.add('completed');
        if (sNum === stepNum) s.classList.add('active');
      });
    }

    function openOnboardingModal() {
      document.getElementById('onboarding-modal').classList.add('active');
      showOnboardingStep('1');
    }

    function closeOnboardingModal() {
      document.getElementById('onboarding-modal').classList.remove('active');
    }

    // 3D tilt effect for robot icon
    document.addEventListener('DOMContentLoaded', function() {
      const robotIcon = document.getElementById('robot-icon');
      if (robotIcon) {
        robotIcon.addEventListener('mousemove', function(e) {
          const rect = this.getBoundingClientRect();
          const x = e.clientX - rect.left - rect.width / 2;
          const y = e.clientY - rect.top - rect.height / 2;
          const rotateX = (-y / rect.height) * 20;
          const rotateY = (x / rect.width) * 20;
          this.style.transform = `perspective(500px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        });
        robotIcon.addEventListener('mouseleave', function() {
          this.style.transform = 'perspective(500px) rotateX(0) rotateY(0)';
        });
      }

      // Setup button - opens onboarding modal
      const setupBtn = document.getElementById('setup-btn');
      if (setupBtn) {
        setupBtn.addEventListener('click', openOnboardingModal);
      }

      // Onboarding close button
      const onboardingClose = document.getElementById('onboarding-close');
      if (onboardingClose) {
        onboardingClose.addEventListener('click', closeOnboardingModal);
      }

      // Onboarding modal backdrop click
      const onboardingModal = document.getElementById('onboarding-modal');
      if (onboardingModal) {
        onboardingModal.addEventListener('click', (e) => {
          if (e.target === onboardingModal) closeOnboardingModal();
        });
      }

      // Setup option clicks
      document.querySelectorAll('.setup-option').forEach(option => {
        option.addEventListener('click', () => {
          const optionType = option.dataset.option;
          document.querySelectorAll('.setup-option').forEach(o => o.classList.remove('selected'));
          option.classList.add('selected');
          
          if (optionType === 'copilot') {
            showOnboardingStep('2-copilot');
          } else if (optionType === 'azure') {
            showOnboardingStep('2-azure');
          } else if (optionType === 'existing') {
            showOnboardingStep('3');
          }
        });
      });

      // Onboarding save endpoint
      const onboardingSave = document.getElementById('onboarding-save-endpoint');
      if (onboardingSave) {
        onboardingSave.addEventListener('click', () => {
          const name = document.getElementById('onboarding-endpoint-name').value.trim();
          const url = document.getElementById('onboarding-endpoint-url').value.trim();
          const key = document.getElementById('onboarding-endpoint-key').value.trim();
          
          if (url) {
            // Save to endpoints (integrate with existing endpoint system)
            const endpoints = JSON.parse(localStorage.getItem('chatAppEndpoints') || '[]');
            const newEndpoint = {
              id: Date.now().toString(),
              name: name || 'RAPP Endpoint',
              url: url,
              key: key,
              isDefault: endpoints.length === 0
            };
            endpoints.push(newEndpoint);
            localStorage.setItem('chatAppEndpoints', JSON.stringify(endpoints));
            
            closeOnboardingModal();
            location.reload(); // Refresh to load new endpoint
          }
        });
      }

      // Import drop zone
      const dropZone = document.getElementById('import-drop-zone');
      const importInput = document.getElementById('onboarding-import-input');
      if (dropZone && importInput) {
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });
        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const file = e.dataTransfer.files[0];
          if (file) handleRAPPidImport(file);
        });
        importInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) handleRAPPidImport(file);
        });
      }
    });

    function handleRAPPidImport(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const config = JSON.parse(e.target.result);
          if (config.endpoint || config.url) {
            document.getElementById('onboarding-endpoint-name').value = config.name || config.endpoint?.name || 'Imported Endpoint';
            document.getElementById('onboarding-endpoint-url').value = config.url || config.endpoint?.url || '';
            document.getElementById('onboarding-endpoint-key').value = config.key || config.endpoint?.key || '';
          }
        } catch (err) {
          console.error('Failed to parse RAPPid.json:', err);
        }
      };
      reader.readAsText(file);
    }

    // Test Script Runner - allows drag/drop of test scripts and arrow key navigation
    const testRunner = {
      script: [],
      currentIndex: -1,
      
      load(data) {
        // Accept array of strings or array of objects with 'message' field
        if (Array.isArray(data)) {
          this.script = data.map(item => typeof item === 'string' ? item : item.message || item.content || String(item));
        } else if (data.messages) {
          // Accept chat export format - extract user messages
          this.script = data.messages.filter(m => m.role === 'user').map(m => m.content);
        } else if (data.testScript) {
          this.script = data.testScript;
        } else {
          this.showStatus('Invalid test script format');
          return;
        }
        
        if (this.script.length === 0) {
          this.showStatus('No test messages found in file');
          return;
        }
        
        this.currentIndex = -1;
        this.showStatus(`Test script loaded: ${this.script.length} messages. Use  arrows to navigate.`);
      },
      
      showStatus(msg) {
        // Play a beep sound
        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          gainNode.gain.value = 0.3;
          oscillator.start();
          oscillator.stop(audioCtx.currentTime + 0.15);
        } catch (e) {}
        
        const toast = document.createElement('div');
        toast.style.cssText = 'position:fixed;bottom:100px;left:50%;transform:translateX(-50%);background:var(--primary);color:white;padding:12px 24px;border-radius:8px;z-index:1000;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);animation:pulse 0.3s ease;';
        toast.textContent = ' ' + msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
      },
      
      next() {
        if (this.script.length === 0) return false;
        if (this.currentIndex < this.script.length - 1) {
          this.currentIndex++;
          const userInput = document.getElementById('user-input');
          if (userInput) {
            userInput.value = this.script[this.currentIndex];
            userInput.focus();
          }
          return true;
        }
        return false;
      },
      
      prev() {
        if (this.script.length === 0) return false;
        if (this.currentIndex > 0) {
          this.currentIndex--;
          const userInput = document.getElementById('user-input');
          if (userInput) {
            userInput.value = this.script[this.currentIndex];
            userInput.focus();
          }
          return true;
        }
        return false;
      },
      
      isActive() {
        return this.script.length > 0;
      },
      
      clear() {
        this.script = [];
        this.currentIndex = -1;
      }
    };

    // Arrow key navigation for test script
    document.addEventListener('keydown', e => {
      const userInput = document.getElementById('user-input');
      if (testRunner.isActive() && document.activeElement === userInput) {
        if (e.key === 'ArrowDown') {
          if (testRunner.next()) {
            e.preventDefault();
          }
        } else if (e.key === 'ArrowUp') {
          if (testRunner.prev()) {
            e.preventDefault();
          }
        }
      }
    });

    // Global state management
    class AppState {
      constructor() {
        this.currentUser = null;
        this.currentChatId = null;
        this.users = this.loadUsers();
        this.chats = this.loadChats();
        this.settings = this.loadSettings();
        this.endpoints = this.loadEndpoints();
        this.activeEndpointId = null;
      }

      loadUsers() {
        const users = localStorage.getItem("chatAppUsers");
        return users ? JSON.parse(users) : {};
      }

      loadChats() {
        const chats = localStorage.getItem("chatAppChats");
        return chats ? JSON.parse(chats) : {};
      }

      loadSettings() {
        const settings = localStorage.getItem("chatAppSettings");
        return settings
          ? JSON.parse(settings)
          : {
            theme: "light",
            soundEnabled: false,
            voiceEnabled: true,
            autoSpeak: false,
            azureTTSKey: "",
            azureRegion: "eastus2",
            ttsVoiceName: "en-US-JennyNeural",
          };
      }

      loadEndpoints() {
        const endpoints = localStorage.getItem("chatAppEndpoints");
        const defaultEndpoints = {
          'default': {
            id: 'default',
            name: 'Default Bot',
            url: "https://effective-bassoon-wvrjj9qrxvcg6vr-7071.app.github.dev/api/businessinsightbot_function",
            key: "",
            guid: "c0p110t0-aaaa-bbbb-cccc-123456789abc",
            active: true
          }
        };
        return endpoints ? JSON.parse(endpoints) : defaultEndpoints;
      }

      saveUsers() {
        localStorage.setItem("chatAppUsers", JSON.stringify(this.users));
      }

      saveChats() {
        localStorage.setItem("chatAppChats", JSON.stringify(this.chats));
      }

      saveSettings() {
        localStorage.setItem(
          "chatAppSettings",
          JSON.stringify(this.settings)
        );
      }

      saveEndpoints() {
        localStorage.setItem("chatAppEndpoints", JSON.stringify(this.endpoints));
      }

      createUser(username) {
        const userId = this.generateGuid();
        const user = {
          id: userId,
          username: username,
          createdAt: new Date().toISOString(),
          lastActive: new Date().toISOString(),
          chats: [],
        };
        this.users[userId] = user;
        this.saveUsers();
        return user;
      }

      createChat(userId, title = "New Chat") {
        const chatId = this.generateGuid();
        const chat = {
          id: chatId,
          userId: userId,
          title: title,
          messages: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          archived: false,
        };

        if (!this.chats[userId]) {
          this.chats[userId] = {};
        }

        this.chats[userId][chatId] = chat;
        this.users[userId].chats.push(chatId);
        this.users[userId].lastActive = new Date().toISOString();

        this.saveChats();
        this.saveUsers();

        return chat;
      }

      createBranchChat(userId, sourceChat, upToIndex) {
        const branchTitle = `${sourceChat.title} (Branch from message ${upToIndex + 1})`;
        const branchChat = this.createChat(userId, branchTitle);

        branchChat.messages = sourceChat.messages.slice(0, upToIndex + 1).map(msg => ({...msg}));
        branchChat.updatedAt = new Date().toISOString();

        this.saveChats();
        return branchChat;
      }

      updateChat(userId, chatId, updates) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          Object.assign(this.chats[userId][chatId], updates);
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      getActiveChats(userId) {
        if (!this.chats[userId]) return [];
        return Object.values(this.chats[userId])
          .filter((chat) => !chat.archived)
          .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      }

      getArchivedChats(userId) {
        if (!this.chats[userId]) return [];
        return Object.values(this.chats[userId])
          .filter((chat) => chat.archived)
          .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      }

      archiveChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          this.chats[userId][chatId].archived = true;
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      unarchiveChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          this.chats[userId][chatId].archived = false;
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      deleteChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          delete this.chats[userId][chatId];
          const userChatIndex = this.users[userId].chats.indexOf(chatId);
          if (userChatIndex > -1) {
            this.users[userId].chats.splice(userChatIndex, 1);
          }
          this.saveChats();
          this.saveUsers();
        }
      }

      addEndpoint(name, url, key, guid) {
        const id = this.generateGuid();
        this.endpoints[id] = {
          id: id,
          name: name,
          url: url,
          key: key,
          guid: guid || "c0p110t0-aaaa-bbbb-cccc-123456789abc",
          active: Object.keys(this.endpoints).length === 0
        };
        this.saveEndpoints();
        return this.endpoints[id];
      }

      updateEndpoint(id, updates) {
        if (this.endpoints[id]) {
          Object.assign(this.endpoints[id], updates);
          this.saveEndpoints();
        }
      }

      deleteEndpoint(id) {
        if (this.endpoints[id]) {
          delete this.endpoints[id];
          this.saveEndpoints();
        }
      }

      setActiveEndpoint(id) {
        Object.values(this.endpoints).forEach(endpoint => {
          endpoint.active = endpoint.id === id;
        });
        this.activeEndpointId = id;
        this.saveEndpoints();
      }

      getActiveEndpoint() {
        return Object.values(this.endpoints).find(e => e.active) || Object.values(this.endpoints)[0];
      }

      getEndpointById(id) {
        return this.endpoints[id];
      }

      exportAllData() {
        return {
          users: this.users,
          chats: this.chats,
          settings: this.settings,
          endpoints: this.endpoints,
          exportDate: new Date().toISOString(),
          version: "1.0",
        };
      }

      importAllData(data) {
        if (data.users) this.users = data.users;
        if (data.chats) this.chats = data.chats;
        if (data.settings) this.settings = data.settings;
        if (data.endpoints) this.endpoints = data.endpoints;

        this.saveUsers();
        this.saveChats();
        this.saveSettings();
        this.saveEndpoints();
      }

      exportSettings() {
        return {
          rappid: true,
          backupType: "RAPPID Settings Backup",
          endpoints: this.endpoints,
          azureTTSKey: this.settings.azureTTSKey,
          azureRegion: this.settings.azureRegion,
          ttsVoiceName: this.settings.ttsVoiceName,
          exportDate: new Date().toISOString(),
          version: "1.0"
        };
      }

      importSettings(settingsData) {
        if (settingsData.azureTTSKey !== undefined) {
          this.settings.azureTTSKey = settingsData.azureTTSKey;
        }
        if (settingsData.azureRegion !== undefined) {
          this.settings.azureRegion = settingsData.azureRegion;
        }
        if (settingsData.ttsVoiceName !== undefined) {
          this.settings.ttsVoiceName = settingsData.ttsVoiceName;
        }
        if (settingsData.endpoints !== undefined) {
          this.endpoints = settingsData.endpoints;
          this.saveEndpoints();
        }

        this.saveSettings();
      }

      clearAllData() {
        localStorage.removeItem("chatAppUsers");
        localStorage.removeItem("chatAppChats");
        localStorage.removeItem("chatAppSettings");
        localStorage.removeItem("chatAppEndpoints");
        localStorage.removeItem("lastUserId");

        this.users = {};
        this.chats = {};
        this.settings = {
          theme: "light",
          soundEnabled: false,
          voiceEnabled: true,
          autoSpeak: false,
          azureTTSKey: "",
          azureRegion: "eastus2",
          ttsVoiceName: "en-US-JennyNeural",
        };
        this.endpoints = {
          'default': {
            id: 'default',
            name: 'Default Bot',
            url: "",
            key: "",
            guid: "c0p110t0-aaaa-bbbb-cccc-123456789abc",
            active: true
          }
        };
      }

      generateGuid() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
          /[xy]/g,
          function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
          }
        );
      }
    }

    // Sound Manager
    class SoundManager {
      constructor() {
        this.audioContext = null;
        this.enabled = false;
      }

      init() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      setEnabled(enabled) {
        this.enabled = enabled;
        if (enabled) this.init();
      }

      async playSound(frequency = 440, duration = 0.1, type = "sine") {
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          this.audioContext.currentTime + duration
        );

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      playSendSound() {
        this.playSound(523.25, 0.1);
      }

      playReceiveSound() {
        this.playSound(659.25, 0.15);
      }

      playNotificationSound() {
        this.playSound(880, 0.2);
      }
    }

    // Voice Manager
    class VoiceManager {
      constructor() {
        this.synthesis = window.speechSynthesis;
        this.recognition = null;
        this.azureRecognizer = null;
        this.enabled = true;
        this.autoSpeak = false;
        this.isListening = false;
        this.isContinuousMode = false;
        this.isSpeaking = false;
        this.azureKey = "";
        this.azureRegion = "eastus2";
        this.voiceName = "en-US-JennyNeural";
        this.isSdkLoaded = false;
        this.speechSynthesizer = null;
        this.maxCharacters = 5000;

        this.initSpeechRecognition();
        this.loadSpeechSdk();
      }

      loadSpeechSdk() {
        if (window.SpeechSDK) {
          this.isSdkLoaded = true;
          return;
        }

        const script = document.createElement("script");
        script.src = "https://aka.ms/csspeech/jsbrowserpackageraw";
        script.async = true;
        script.onload = () => {
          console.log("Microsoft Speech SDK loaded");
          this.isSdkLoaded = true;
        };
        script.onerror = () => {
          console.error("Failed to load Microsoft Speech SDK");
        };

        document.body.appendChild(script);
      }

      initSpeechRecognition() {
        if (
          "webkitSpeechRecognition" in window ||
          "SpeechRecognition" in window
        ) {
          const SpeechRecognition =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          this.recognition = new SpeechRecognition();
          this.recognition.continuous = false;
          this.recognition.interimResults = true;
          this.recognition.lang = "en-US";

          this.recognition.onstart = () => {
            this.isListening = true;
            document.getElementById("voice-toggle").classList.add("active");
          };

          this.recognition.onend = () => {
            this.isListening = false;
            document
              .getElementById("voice-toggle")
              .classList.remove("active");
          };

          this.recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            this.isListening = false;
            document
              .getElementById("voice-toggle")
              .classList.remove("active");
          };
        }
      }

      setEnabled(enabled) {
        this.enabled = enabled;
      }

      setAutoSpeak(autoSpeak) {
        this.autoSpeak = autoSpeak;
      }

      setAzureKey(key) {
        this.azureKey = key;
      }

      setAzureRegion(region) {
        this.azureRegion = region;
      }

      setVoiceName(voiceName) {
        this.voiceName = voiceName;
      }

      async speak(text) {
        if (!this.enabled || !text || this.isSpeaking) return;

        this.stopSpeaking();

        const cleanText = this.cleanTextForSpeech(text);

        if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
          await this.speakWithAzure(cleanText);
        } else {
          await this.speakWithBrowser(cleanText);
        }
      }

      async speakWithAzure(text) {
        try {
          const truncatedText =
            text.length > this.maxCharacters
              ? text.substring(0, this.maxCharacters) +
              "... (text truncated for speech)"
              : text;

          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.azureKey,
            this.azureRegion
          );
          speechConfig.speechSynthesisVoiceName = this.voiceName;

          const audioConfig =
            window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
          this.speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(
            speechConfig,
            audioConfig
          );

          this.isSpeaking = true;
          document.getElementById("voice-indicator").classList.add("active");

          await new Promise((resolve, reject) => {
            this.speechSynthesizer.speakTextAsync(
              truncatedText,
              (result) => {
                if (
                  result.reason ===
                  window.SpeechSDK.ResultReason.SynthesizingAudioCompleted
                ) {
                  console.log("Azure TTS synthesis completed");
                  this.isSpeaking = false;
                  document
                    .getElementById("voice-indicator")
                    .classList.remove("active");

                  if (this.speechSynthesizer) {
                    this.speechSynthesizer.close();
                    this.speechSynthesizer = null;
                  }
                  resolve();
                } else {
                  console.error(
                    `Speech synthesis canceled, reason: ${result.reason}`
                  );
                  let errorDetails = "";

                  if (
                    result.reason === window.SpeechSDK.ResultReason.Canceled
                  ) {
                    const cancellationDetails =
                      window.SpeechSDK.CancellationDetails.fromResult(result);
                    errorDetails = `Cancellation reason: ${cancellationDetails.reason}`;

                    if (
                      cancellationDetails.reason ===
                      window.SpeechSDK.CancellationReason.Error
                    ) {
                      errorDetails += `, Error details: ${cancellationDetails.errorDetails}`;
                    }
                  }

                  if (this.speechSynthesizer) {
                    this.speechSynthesizer.close();
                    this.speechSynthesizer = null;
                  }

                  this.isSpeaking = false;
                  document
                    .getElementById("voice-indicator")
                    .classList.remove("active");
                  reject(
                    new Error(`Speech synthesis failed. ${errorDetails}`)
                  );
                }
              },
              (error) => {
                console.error("Azure TTS error:", error);

                if (this.speechSynthesizer) {
                  this.speechSynthesizer.close();
                  this.speechSynthesizer = null;
                }

                this.isSpeaking = false;
                document
                  .getElementById("voice-indicator")
                  .classList.remove("active");
                reject(error);
              }
            );
          });
        } catch (error) {
          console.error("Azure TTS error:", error);
          this.isSpeaking = false;
          document
            .getElementById("voice-indicator")
            .classList.remove("active");
          await this.speakWithBrowser(text);
        }
      }

      async speakWithBrowser(text) {
        return new Promise((resolve, reject) => {
          try {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            const voices = this.synthesis.getVoices();
            const preferredVoice =
              voices.find(
                (voice) =>
                  voice.name.includes("Microsoft") ||
                  voice.name.includes("Google") ||
                  voice.name.includes("Natural")
              ) || voices[0];

            if (preferredVoice) {
              utterance.voice = preferredVoice;
            }

            utterance.onstart = () => {
              this.isSpeaking = true;
              document
                .getElementById("voice-indicator")
                .classList.add("active");
            };

            utterance.onend = () => {
              this.isSpeaking = false;
              document
                .getElementById("voice-indicator")
                .classList.remove("active");
              resolve();
            };

            utterance.onerror = (error) => {
              this.isSpeaking = false;
              document
                .getElementById("voice-indicator")
                .classList.remove("active");
              reject(error);
            };

            this.synthesis.speak(utterance);
          } catch (error) {
            this.isSpeaking = false;
            document
              .getElementById("voice-indicator")
              .classList.remove("active");
            reject(error);
          }
        });
      }

      stopSpeaking() {
        if (this.speechSynthesizer) {
          try {
            this.speechSynthesizer.close();
          } catch (e) {
            console.warn("Error closing speech synthesizer:", e);
          }
          this.speechSynthesizer = null;
        }

        if (window.speechSynthesis) {
          try {
            window.speechSynthesis.cancel();
          } catch (e) {
            console.warn("Error canceling speech synthesis:", e);
          }
        }

        this.isSpeaking = false;
        document.getElementById("voice-indicator").classList.remove("active");
      }

      cleanTextForSpeech(text) {
        let cleanText = text.replace(/<[^>]*>/g, " ");

        cleanText = cleanText
          .replace(/\*\*([^*]+)\*\*/g, "$1")
          .replace(/\*([^*]+)\*/g, "$1")
          .replace(/`([^`]+)`/g, "$1")
          .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
          .replace(/#{1,6}\s+([^\n]+)/g, "$1")
          .replace(/```[\s\S]*?```/g, "")
          .replace(/\n/g, " ")
          .replace(/\s+/g, " ")
          .trim();

        return cleanText;
      }

      async startListening(callback) {
        if (this.isListening) return;

        // Use Azure Speech-to-Text if available
        if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
          await this.startListeningWithAzure(callback);
        } else if (this.recognition) {
          // Fallback to browser Web Speech API
          this.startListeningWithBrowser(callback);
        } else {
          console.error("No speech recognition available");
        }
      }

      startListeningWithBrowser(callback) {
        if (!this.recognition) return;

        this.recognition.onresult = (event) => {
          const last = event.results.length - 1;
          const transcript = event.results[last][0].transcript;

          if (event.results[last].isFinal) {
            callback(transcript);
          }
        };

        this.recognition.start();
      }

      async startListeningWithAzure(callback) {
        try {
          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.azureKey,
            this.azureRegion
          );
          speechConfig.speechRecognitionLanguage = "en-US";

          const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
          const recognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

          this.isListening = true;
          document.getElementById("voice-toggle").classList.add("active");

          // Handle recognized speech
          recognizer.recognized = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
              console.log("Azure STT recognized:", e.result.text);
              callback(e.result.text);

              // Stop listening after recognition
              this.isListening = false;
              document.getElementById("voice-toggle").classList.remove("active");
              recognizer.close();
            }
          };

          // Handle errors
          recognizer.canceled = (s, e) => {
            console.error("Azure STT canceled:", e.errorDetails);
            this.isListening = false;
            document.getElementById("voice-toggle").classList.remove("active");
            recognizer.close();

            // Fallback to browser speech recognition
            if (this.recognition) {
              console.log("Falling back to browser speech recognition");
              this.startListeningWithBrowser(callback);
            }
          };

          // Handle session stopped
          recognizer.sessionStopped = (s, e) => {
            console.log("Azure STT session stopped");
            this.isListening = false;
            document.getElementById("voice-toggle").classList.remove("active");
            recognizer.close();
          };

          // Start recognition
          recognizer.recognizeOnceAsync(
            (result) => {
              if (result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                console.log("Azure STT final result:", result.text);
              }
            },
            (error) => {
              console.error("Azure STT error:", error);
              this.isListening = false;
              document.getElementById("voice-toggle").classList.remove("active");

              // Fallback to browser speech recognition
              if (this.recognition) {
                console.log("Falling back to browser speech recognition");
                this.startListeningWithBrowser(callback);
              }
            }
          );

          // Store recognizer reference for stopping
          this.azureRecognizer = recognizer;

        } catch (error) {
          console.error("Azure STT initialization error:", error);
          this.isListening = false;
          document.getElementById("voice-toggle").classList.remove("active");

          // Fallback to browser speech recognition
          if (this.recognition) {
            console.log("Falling back to browser speech recognition");
            this.startListeningWithBrowser(callback);
          }
        }
      }

      // Continuous listening for real-time order taking
      async startContinuousListening(onInterim, onFinal, onError) {
        if (this.isListening) return;

        // Use Azure continuous recognition if available
        if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
          await this.startContinuousListeningWithAzure(onInterim, onFinal, onError);
        } else {
          console.error("Azure Speech SDK required for continuous listening");
          if (onError) onError("Azure Speech SDK not configured");
        }
      }

      async startContinuousListeningWithAzure(onInterim, onFinal, onError) {
        try {
          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.azureKey,
            this.azureRegion
          );
          speechConfig.speechRecognitionLanguage = "en-US";

          const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
          const recognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

          this.isListening = true;
          this.isContinuousMode = true;
          document.getElementById("voice-toggle")?.classList.add("active");

          let fullTranscript = "";

          // Handle interim results (partial recognition)
          recognizer.recognizing = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
              const interimText = e.result.text;
              console.log("Interim:", interimText);
              if (onInterim) {
                onInterim(fullTranscript + " " + interimText, interimText);
              }
            }
          };

          // Handle final results (complete phrases)
          recognizer.recognized = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
              const finalText = e.result.text;
              console.log("Final:", finalText);
              fullTranscript += (fullTranscript ? " " : "") + finalText;

              if (onFinal) {
                onFinal(fullTranscript, finalText);
              }
            }
          };

          // Handle errors
          recognizer.canceled = (s, e) => {
            console.error("Azure continuous STT canceled:", e.errorDetails);
            this.isListening = false;
            this.isContinuousMode = false;
            document.getElementById("voice-toggle")?.classList.remove("active");

            if (onError) {
              onError(e.errorDetails);
            }

            recognizer.stopContinuousRecognitionAsync();
          };

          // Handle session stopped
          recognizer.sessionStopped = (s, e) => {
            console.log("Azure continuous STT session stopped");
            this.isListening = false;
            this.isContinuousMode = false;
            document.getElementById("voice-toggle")?.classList.remove("active");
            recognizer.stopContinuousRecognitionAsync();
          };

          // Store recognizer reference
          this.azureRecognizer = recognizer;

          // Start continuous recognition
          recognizer.startContinuousRecognitionAsync(
            () => {
              console.log("Continuous recognition started");
            },
            (error) => {
              console.error("Failed to start continuous recognition:", error);
              this.isListening = false;
              this.isContinuousMode = false;
              document.getElementById("voice-toggle")?.classList.remove("active");
              if (onError) onError(error);
            }
          );

        } catch (error) {
          console.error("Azure continuous STT initialization error:", error);
          this.isListening = false;
          this.isContinuousMode = false;
          document.getElementById("voice-toggle")?.classList.remove("active");
          if (onError) onError(error.message);
        }
      }

      stopContinuousListening() {
        if (this.azureRecognizer && this.isContinuousMode) {
          try {
            this.azureRecognizer.stopContinuousRecognitionAsync(
              () => {
                console.log("Continuous recognition stopped");
                this.azureRecognizer.close();
                this.azureRecognizer = null;
              },
              (error) => {
                console.error("Error stopping continuous recognition:", error);
                this.azureRecognizer.close();
                this.azureRecognizer = null;
              }
            );
          } catch (error) {
            console.error("Error closing Azure recognizer:", error);
          }
        }

        this.isListening = false;
        this.isContinuousMode = false;
        document.getElementById("voice-toggle")?.classList.remove("active");
      }

      stopListening() {
        // Stop continuous mode if active
        if (this.isContinuousMode) {
          this.stopContinuousListening();
          return;
        }

        // Stop Azure recognizer if active
        if (this.azureRecognizer) {
          try {
            this.azureRecognizer.close();
            this.azureRecognizer = null;
          } catch (error) {
            console.error("Error closing Azure recognizer:", error);
          }
        }

        // Stop browser recognition if active
        if (this.recognition && this.isListening) {
          this.recognition.stop();
        }

        this.isListening = false;
        document.getElementById("voice-toggle")?.classList.remove("active");
      }

      toggleListening(callback) {
        if (this.isListening) {
          this.stopListening();
        } else {
          this.startListening(callback);
        }
      }
    }

    // Time Machine
    class TimeMachine {
      constructor() {
        this.messages = [];
        this.currentIndex = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.sourceChat = null;
      }

      init(messages, sourceChat) {
        this.messages = messages;
        this.currentIndex = 0;
        this.isPlaying = false;
        this.sourceChat = sourceChat;
        this.updateProgress();
      }

      play() {
        if (this.isPlaying) return;
        this.isPlaying = true;

        this.playInterval = setInterval(() => {
          if (this.currentIndex >= this.messages.length - 1) {
            this.pause();
            return;
          }
          this.next();
        }, 1500);

        this.updatePlayButton();
      }

      pause() {
        this.isPlaying = false;
        if (this.playInterval) {
          clearInterval(this.playInterval);
          this.playInterval = null;
        }
        this.updatePlayButton();
      }

      next() {
        if (this.currentIndex < this.messages.length - 1) {
          this.currentIndex++;
          this.displayUpToIndex();
          this.updateProgress();
        }
      }

      prev() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.displayUpToIndex();
          this.updateProgress();
        }
      }

      stop() {
        this.pause();
        this.currentIndex = this.messages.length - 1;
        this.displayUpToIndex();
        this.updateProgress();
        document
          .getElementById("time-machine-modal")
          .classList.remove("active");
      }

      branchFromCurrentPoint() {
        if (!this.sourceChat) return null;

        const branchChat = appState.createBranchChat(
          appState.currentUser.id,
          this.sourceChat,
          this.currentIndex
        );

        return branchChat;
      }

      displayUpToIndex() {
        const chatMessages = document.getElementById("chat-messages");
        chatMessages.innerHTML = "";

        for (let i = 0; i <= this.currentIndex; i++) {
          const msg = this.messages[i];
          ui.addMessageToUI(msg.role, msg.content, false);
        }

        ui.scrollToBottom();
      }

      updateProgress() {
        const progress = document.getElementById("time-machine-progress");
        progress.textContent = `${this.currentIndex + 1} / ${this.messages.length}`;
      }

      updatePlayButton() {
        const playButton = document.getElementById("time-machine-play");
        const icon = playButton.querySelector("i");
        if (this.isPlaying) {
          icon.className = "fas fa-pause";
        } else {
          icon.className = "fas fa-play";
        }
      }
    }

    // Initialize global instances
    const appState = new AppState();
    const soundManager = new SoundManager();
    const voiceManager = new VoiceManager();
    const timeMachine = new TimeMachine();

    // UI Controller
    class UIController {
      constructor() {
        this.loginPage = document.getElementById("login-page");
        this.appPage = document.getElementById("app");
        this.sidebar = document.getElementById("sidebar");
        this.sidebarOverlay = document.getElementById("sidebar-overlay");
        this.chatMessages = document.getElementById("chat-messages");
        this.userInput = document.getElementById("user-input");
        this.sendButton = document.getElementById("send-button");
        this.imagePreviewContainer = document.getElementById(
          "image-preview-container"
        );
        this.mentionDropdown = document.getElementById("mention-dropdown");
        this.pendingImage = null;
        this.mentionActive = false;
        this.mentionStartPos = -1;
        this.selectedMentionIndex = 0;
        this.currentEndpointId = null;
        this.editingEndpointId = null;

        this.initializeEventListeners();
        this.checkExistingSession();
      }

      initializeEventListeners() {
        // Login form
        document
          .getElementById("login-form")
          .addEventListener("submit", (e) => {
            e.preventDefault();
            this.handleLogin();
          });

        // Header buttons
        document
          .getElementById("sidebar-toggle")
          .addEventListener("click", () => {
            this.toggleSidebar();
          });

        document
          .getElementById("archive-chat")
          .addEventListener("click", () => {
            this.archiveCurrentChat();
          });

        document
          .getElementById("theme-toggle")
          .addEventListener("click", () => {
            this.toggleTheme();
          });

        document.getElementById("logout").addEventListener("click", () => {
          this.logout();
        });

        // Clear chat button (floating)
        document
          .getElementById("clear-chat")
          .addEventListener("click", () => {
            this.clearCurrentChat();
          });

        // Voice toggle button
        document
          .getElementById("voice-toggle")
          .addEventListener("click", () => {
            if (!voiceManager.recognition) {
              this.showNotification(
                "Voice input is not supported in your browser. Please use Chrome or text input.",
                "warning"
              );
              return;
            }

            if (!appState.settings.voiceEnabled) {
              this.showNotification(
                "Voice features are disabled. Enable them in settings.",
                "info"
              );
              this.openSettings();
              return;
            }

            voiceManager.toggleListening((transcript) => {
              this.userInput.value = transcript;
              this.sendMessage();
            });
          });

        // Sidebar
        this.sidebarOverlay.addEventListener("click", () => {
          this.toggleSidebar();
        });

        // Sidebar tabs
        document.querySelectorAll(".sidebar-tab").forEach((tab) => {
          tab.addEventListener("click", (e) => {
            this.switchSidebarTab(e.target.dataset.tab);
          });
        });

        // Chat controls
        document.getElementById("new-chat").addEventListener("click", () => {
          this.createNewChat();
          this.toggleSidebar();
        });

        document
          .getElementById("send-button")
          .addEventListener("click", () => {
            this.sendMessage();
          });

        this.userInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            this.sendMessage();
          }
        });

        // Mention autocomplete
        this.userInput.addEventListener("input", (e) => {
          this.handleMentionInput(e);

          // Auto-resize textarea
          this.userInput.style.height = "auto";
          this.userInput.style.height =
            Math.min(this.userInput.scrollHeight, 120) + "px";
        });

        this.userInput.addEventListener("keydown", (e) => {
          if (this.mentionActive) {
            this.handleMentionNavigation(e);
          }
        });

        // Image upload
        document
          .getElementById("upload-image")
          .addEventListener("click", () => {
            document.getElementById("image-upload-input").click();
          });

        document
          .getElementById("image-upload-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.handleImageUpload(e.target.files[0]);
            }
          });

        // Paste event for images
        this.userInput.addEventListener("paste", (e) => {
          const items = e.clipboardData.items;
          for (let item of items) {
            if (item.type.indexOf("image") !== -1) {
              const file = item.getAsFile();
              this.handleImageUpload(file);
              e.preventDefault();
            }
          }
        });

        // Menu
        const menuToggle = document.getElementById("menu-toggle");
        const menuItems = document.getElementById("menu-items");

        menuToggle.addEventListener("click", () => {
          const isOpen = menuToggle.classList.toggle("active");
          menuItems.classList.toggle("open");
        });

        // Close menu when clicking outside
        document.addEventListener("click", (e) => {
          if (
            !menuToggle.contains(e.target) &&
            !menuItems.contains(e.target)
          ) {
            menuToggle.classList.remove("active");
            menuItems.classList.remove("open");
          }
        });

        // Menu items
        document
          .getElementById("export-chat")
          .addEventListener("click", () => {
            this.exportCurrentChat();
            this.closeMenu();
          });

        document
          .getElementById("import-chat")
          .addEventListener("click", () => {
            document.getElementById("chat-import-input").click();
            this.closeMenu();
          });

        document
          .getElementById("export-all")
          .addEventListener("click", () => {
            this.exportAllData();
            this.closeMenu();
          });

        document
          .getElementById("import-all")
          .addEventListener("click", () => {
            document.getElementById("data-import-input").click();
            this.closeMenu();
          });

        document
          .getElementById("time-machine")
          .addEventListener("click", () => {
            this.openTimeMachine();
            this.closeMenu();
          });

        document.getElementById("settings").addEventListener("click", () => {
          this.openSettings();
          this.closeMenu();
        });

        // File inputs
        document
          .getElementById("chat-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importChat(e.target.files[0]);
            }
          });

        document
          .getElementById("data-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importAllData(e.target.files[0]);
            }
          });

        // Settings import/export
        document
          .getElementById("export-settings")
          .addEventListener("click", () => {
            this.exportSettings();
          });

        document
          .getElementById("import-settings")
          .addEventListener("click", () => {
            document.getElementById("settings-import-input").click();
          });

        document
          .getElementById("settings-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importSettings(e.target.files[0]);
            }
          });

        // Drag and drop
        this.initializeDragAndDrop();

        // Settings modal
        document
          .getElementById("settings-close")
          .addEventListener("click", () => {
            document
              .getElementById("settings-modal")
              .classList.remove("active");
          });

        document
          .getElementById("cancel-settings")
          .addEventListener("click", () => {
            document
              .getElementById("settings-modal")
              .classList.remove("active");
          });

        document
          .getElementById("save-all-settings")
          .addEventListener("click", () => {
            this.saveAllSettings();
          });

        document
          .getElementById("dark-mode-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("sound-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("voice-enabled-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("auto-speak-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("clear-all-data")
          .addEventListener("click", () => {
            if (
              confirm(
                "Are you sure you want to clear all data? This cannot be undone."
              )
            ) {
              appState.clearAllData();
              location.reload();
            }
          });

        // Endpoint management
        document
          .getElementById("add-endpoint")
          .addEventListener("click", () => {
            this.openEndpointModal();
          });

        document
          .getElementById("endpoint-modal-close")
          .addEventListener("click", () => {
            this.closeEndpointModal();
          });

        document
          .getElementById("cancel-endpoint")
          .addEventListener("click", () => {
            this.closeEndpointModal();
          });

        document
          .getElementById("save-endpoint")
          .addEventListener("click", () => {
            this.saveEndpoint();
          });

        // Time Machine modal
        document
          .getElementById("time-machine-close")
          .addEventListener("click", () => {
            timeMachine.stop();
          });

        document
          .getElementById("time-machine-start")
          .addEventListener("click", () => {
            const chat =
              appState.chats[appState.currentUser.id][appState.currentChatId];
            if (chat && chat.messages.length > 0) {
              timeMachine.init(chat.messages, chat);
              document
                .getElementById("time-machine-controls")
                .classList.remove("hidden");
              timeMachine.displayUpToIndex();
            }
          });

        document
          .getElementById("time-machine-prev")
          .addEventListener("click", () => {
            timeMachine.prev();
          });

        document
          .getElementById("time-machine-play")
          .addEventListener("click", () => {
            if (timeMachine.isPlaying) {
              timeMachine.pause();
            } else {
              timeMachine.play();
            }
          });

        document
          .getElementById("time-machine-next")
          .addEventListener("click", () => {
            timeMachine.next();
          });

        document
          .getElementById("time-machine-stop")
          .addEventListener("click", () => {
            timeMachine.stop();
          });

        document
          .getElementById("time-machine-branch")
          .addEventListener("click", () => {
            const branchChat = timeMachine.branchFromCurrentPoint();
            if (branchChat) {
              document
                .getElementById("time-machine-modal")
                .classList.remove("active");

              this.loadChat(branchChat.id);
              this.loadUserChats("active");

              this.showNotification(
                `Created branch from message ${timeMachine.currentIndex + 1}. You can now continue the conversation from this point.`,
                "success"
              );
            }
          });
      }

      handleMentionInput(e) {
        const value = this.userInput.value;
        const cursorPos = this.userInput.selectionStart;

        // Check for @ symbol
        const lastAtPos = value.lastIndexOf('@', cursorPos - 1);

        if (lastAtPos >= 0 && (lastAtPos === 0 || value[lastAtPos - 1] === ' ')) {
          const searchTerm = value.substring(lastAtPos + 1, cursorPos).toLowerCase();

          // Don't show dropdown if there's a space after @
          if (searchTerm.includes(' ')) {
            this.closeMentionDropdown();
            return;
          }

          this.mentionActive = true;
          this.mentionStartPos = lastAtPos;
          this.showMentionDropdown(searchTerm);
        } else {
          this.closeMentionDropdown();
        }
      }

      showMentionDropdown(searchTerm) {
        const endpoints = Object.values(appState.endpoints).filter(endpoint =>
          endpoint.name.toLowerCase().includes(searchTerm)
        );

        if (endpoints.length === 0) {
          this.closeMentionDropdown();
          return;
        }

        this.mentionDropdown.innerHTML = '';
        this.selectedMentionIndex = 0;

        endpoints.forEach((endpoint, index) => {
          const item = document.createElement('div');
          item.className = 'mention-item' + (index === 0 ? ' selected' : '');
          item.innerHTML = `
            <div class="mention-item-icon">${endpoint.name.charAt(0).toUpperCase()}</div>
            <div class="mention-item-info">
              <div class="mention-item-name">${endpoint.name}</div>
              <div class="mention-item-url">${endpoint.url}</div>
            </div>
          `;

          item.addEventListener('click', () => {
            this.selectMention(endpoint);
          });

          this.mentionDropdown.appendChild(item);
        });

        this.mentionDropdown.classList.add('active');
      }

      handleMentionNavigation(e) {
        const items = this.mentionDropdown.querySelectorAll('.mention-item');

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          this.selectedMentionIndex = Math.min(this.selectedMentionIndex + 1, items.length - 1);
          this.updateMentionSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          this.selectedMentionIndex = Math.max(this.selectedMentionIndex - 1, 0);
          this.updateMentionSelection();
        } else if (e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          const endpoints = Object.values(appState.endpoints);
          const visibleEndpoints = Array.from(items).map(item => {
            const name = item.querySelector('.mention-item-name').textContent;
            return endpoints.find(ep => ep.name === name);
          });

          if (visibleEndpoints[this.selectedMentionIndex]) {
            this.selectMention(visibleEndpoints[this.selectedMentionIndex]);
          }
        } else if (e.key === 'Escape') {
          this.closeMentionDropdown();
        }
      }

      updateMentionSelection() {
        const items = this.mentionDropdown.querySelectorAll('.mention-item');
        items.forEach((item, index) => {
          item.classList.toggle('selected', index === this.selectedMentionIndex);
        });
      }

      selectMention(endpoint) {
        const value = this.userInput.value;
        const beforeMention = value.substring(0, this.mentionStartPos);
        const afterMention = value.substring(this.userInput.selectionStart);

        this.userInput.value = `${beforeMention}@${endpoint.name} ${afterMention}`;
        this.currentEndpointId = endpoint.id;

        const newCursorPos = beforeMention.length + endpoint.name.length + 2;
        this.userInput.setSelectionRange(newCursorPos, newCursorPos);

        this.closeMentionDropdown();
        this.userInput.focus();
      }

      closeMentionDropdown() {
        this.mentionActive = false;
        this.mentionStartPos = -1;
        this.selectedMentionIndex = 0;
        this.mentionDropdown.classList.remove('active');
        this.mentionDropdown.innerHTML = '';
      }

      openEndpointModal(endpointId = null) {
        this.editingEndpointId = endpointId;
        const modal = document.getElementById('endpoint-modal');
        const title = document.getElementById('endpoint-modal-title');

        if (endpointId) {
          title.textContent = 'Edit Endpoint';
          const endpoint = appState.getEndpointById(endpointId);
          document.getElementById('endpoint-name').value = endpoint.name;
          document.getElementById('endpoint-url').value = endpoint.url;
          document.getElementById('endpoint-key').value = endpoint.key;
          document.getElementById('endpoint-guid').value = endpoint.guid;
        } else {
          title.textContent = 'Add Endpoint';
          document.getElementById('endpoint-name').value = '';
          document.getElementById('endpoint-url').value = '';
          document.getElementById('endpoint-key').value = '';
          document.getElementById('endpoint-guid').value = 'c0p110t0-aaaa-bbbb-cccc-123456789abc';
        }

        modal.classList.add('active');
      }

      closeEndpointModal() {
        document.getElementById('endpoint-modal').classList.remove('active');
        this.editingEndpointId = null;
      }

      saveEndpoint() {
        const name = document.getElementById('endpoint-name').value.trim();
        const url = document.getElementById('endpoint-url').value.trim();
        const key = document.getElementById('endpoint-key').value.trim();
        const guid = document.getElementById('endpoint-guid').value.trim() || 'c0p110t0-aaaa-bbbb-cccc-123456789abc';

        if (!name || !url) {
          this.showNotification('Please fill in name and URL', 'warning');
          return;
        }

        if (this.editingEndpointId) {
          appState.updateEndpoint(this.editingEndpointId, { name, url, key, guid });
        } else {
          appState.addEndpoint(name, url, key, guid);
        }

        this.loadEndpointList();
        this.closeEndpointModal();
        this.showNotification('Endpoint saved successfully!', 'success');
      }

      loadEndpointList() {
        const endpointList = document.getElementById('endpoint-list');
        endpointList.innerHTML = '';

        const endpoints = Object.values(appState.endpoints);

        if (endpoints.length === 0) {
          endpointList.innerHTML = '<p style="color: var(--gray-60); text-align: center; padding: 20px;">No endpoints configured</p>';
          return;
        }

        endpoints.forEach(endpoint => {
          const item = document.createElement('div');
          item.className = 'endpoint-item';
          item.innerHTML = `
            <div class="endpoint-item-icon">${endpoint.name.charAt(0).toUpperCase()}</div>
            <div class="endpoint-item-info">
              <div class="endpoint-item-name">${endpoint.name}</div>
              <div class="endpoint-item-url">${endpoint.url}</div>
            </div>
            <div class="endpoint-item-actions">
              <button class="endpoint-item-action ${endpoint.active ? 'active' : ''}" title="${endpoint.active ? 'Active' : 'Set as default'}">
                <i class="fas fa-check"></i>
              </button>
              <button class="endpoint-item-action" title="Edit">
                <i class="fas fa-edit"></i>
              </button>
              <button class="endpoint-item-action" title="Delete">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          `;

          const actions = item.querySelectorAll('.endpoint-item-action');

          // Set active
          actions[0].addEventListener('click', () => {
            appState.setActiveEndpoint(endpoint.id);
            this.loadEndpointList();
          });

          // Edit
          actions[1].addEventListener('click', () => {
            this.openEndpointModal(endpoint.id);
          });

          // Delete
          actions[2].addEventListener('click', () => {
            if (confirm(`Delete endpoint "${endpoint.name}"?`)) {
              appState.deleteEndpoint(endpoint.id);
              this.loadEndpointList();
            }
          });

          endpointList.appendChild(item);
        });
      }

      initializeDragAndDrop() {
        const dropZone = document.getElementById("drop-zone");
        let dragCounter = 0;

        document.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dragCounter++;
          dropZone.classList.add("active");
        });

        document.addEventListener("dragleave", (e) => {
          e.preventDefault();
          dragCounter--;
          if (dragCounter === 0) {
            dropZone.classList.remove("active");
          }
        });

        document.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        document.addEventListener("drop", (e) => {
          e.preventDefault();
          dragCounter = 0;
          dropZone.classList.remove("active");

          const files = Array.from(e.dataTransfer.files);
          files.forEach((file) => {
            if (file.type.startsWith("image/")) {
              this.handleImageUpload(file);
            } else if (file.type === "application/json") {
              this.handleJsonImport(file);
            }
          });
        });
      }

      checkExistingSession() {
        const lastUserId = localStorage.getItem("lastUserId");
        if (lastUserId && appState.users[lastUserId]) {
          appState.currentUser = appState.users[lastUserId];
          this.showApp();
        } else {
          this.showLogin();
        }
      }

      showLogin() {
        this.loginPage.classList.remove("hidden");
        this.appPage.classList.add("hidden");
        this.loadRecentUsers();
      }

      showApp() {
        this.loginPage.classList.add("hidden");
        this.appPage.classList.remove("hidden");

        document.getElementById("current-username").textContent =
          appState.currentUser.username;

        this.loadUserChats();
        this.applyTheme();
        this.applySettings();

        const activeChats = appState.getActiveChats(appState.currentUser.id);
        if (activeChats.length > 0) {
          this.loadChat(activeChats[0].id);
        } else {
          this.createNewChat();
        }
      }

      loadRecentUsers() {
        const recentUsersContainer = document.getElementById("recent-users");
        recentUsersContainer.innerHTML = "";

        const users = Object.values(appState.users)
          .sort((a, b) => new Date(b.lastActive) - new Date(a.lastActive))
          .slice(0, 5);

        users.forEach((user) => {
          const userElement = document.createElement("div");
          userElement.className = "user-item";
          userElement.innerHTML = `
            <div class="user-info">
              <div class="user-name">${user.username}</div>
              <div class="user-last-active">Last active: ${this.formatDate(
            user.lastActive
          )}</div>
            </div>
            <i class="fas fa-chevron-right"></i>
          `;
          userElement.addEventListener("click", () => {
            document.getElementById("username").value = user.username;
            this.handleLogin();
          });
          recentUsersContainer.appendChild(userElement);
        });
      }

      handleLogin() {
        const username = document.getElementById("username").value.trim();
        if (!username) return;

        let user = Object.values(appState.users).find(
          (u) => u.username === username
        );
        if (!user) {
          user = appState.createUser(username);
        }

        appState.currentUser = user;
        localStorage.setItem("lastUserId", user.id);

        this.showApp();
      }

      logout() {
        appState.currentUser = null;
        localStorage.removeItem("lastUserId");
        this.showLogin();
      }

      toggleSidebar() {
        this.sidebar.classList.toggle("open");
        this.sidebarOverlay.classList.toggle("active");
      }

      switchSidebarTab(tab) {
        document.querySelectorAll(".sidebar-tab").forEach((t) => {
          t.classList.toggle("active", t.dataset.tab === tab);
        });

        document
          .getElementById("chat-list-active")
          .classList.toggle("hidden", tab !== "active");
        document
          .getElementById("chat-list-archived")
          .classList.toggle("hidden", tab !== "archived");

        this.loadUserChats(tab);
      }

      loadUserChats(tab = "active") {
        const containerId =
          tab === "active" ? "chat-list-active" : "chat-list-archived";
        const chatList = document.getElementById(containerId);
        chatList.innerHTML = "";

        const chats =
          tab === "active"
            ? appState.getActiveChats(appState.currentUser.id)
            : appState.getArchivedChats(appState.currentUser.id);

        if (chats.length === 0) {
          chatList.innerHTML = `<div class="chat-list-empty">No ${tab} chats</div>`;
          return;
        }

        chats.forEach((chat) => {
          const chatElement = document.createElement("div");
          chatElement.className = "chat-item";
          if (chat.id === appState.currentChatId) {
            chatElement.classList.add("active");
          }

          const lastMessage = chat.messages[chat.messages.length - 1];
          const preview = lastMessage
            ? this.truncateText(lastMessage.content, 50)
            : "New conversation";

          chatElement.innerHTML = `
            <div class="chat-item-title">${chat.title}</div>
            <div class="chat-item-preview">${preview}</div>
            <div class="chat-item-date">${this.formatDate(
            chat.updatedAt
          )}</div>
            <div class="chat-item-actions">
              ${tab === "active"
              ? '<button class="chat-item-action" title="Archive"><i class="fas fa-archive"></i></button>'
              : '<button class="chat-item-action" title="Restore"><i class="fas fa-undo"></i></button>'
            }
              <button class="chat-item-action" title="Delete"><i class="fas fa-trash"></i></button>
            </div>
          `;

          chatElement.addEventListener("click", (e) => {
            if (!e.target.closest(".chat-item-action")) {
              this.loadChat(chat.id);
              this.toggleSidebar();
            }
          });

          const archiveBtn = chatElement.querySelector(
            ".chat-item-action:first-child"
          );
          archiveBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (tab === "active") {
              appState.archiveChat(appState.currentUser.id, chat.id);
              if (chat.id === appState.currentChatId) {
                this.createNewChat();
              }
            } else {
              appState.unarchiveChat(appState.currentUser.id, chat.id);
            }
            this.loadUserChats(tab);
          });

          const deleteBtn = chatElement.querySelector(
            ".chat-item-action:last-child"
          );
          deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (
              confirm(
                "Are you sure you want to permanently delete this chat?"
              )
            ) {
              appState.deleteChat(appState.currentUser.id, chat.id);
              if (chat.id === appState.currentChatId) {
                this.createNewChat();
              }
              this.loadUserChats(tab);
            }
          });

          chatList.appendChild(chatElement);
        });
      }

      createNewChat() {
        const chat = appState.createChat(appState.currentUser.id);
        appState.currentChatId = chat.id;
        this.currentEndpointId = null;
        this.loadUserChats("active");
        this.clearChatMessages();
      }

      loadChat(chatId) {
        const chat = appState.chats[appState.currentUser.id][chatId];
        if (!chat) return;

        appState.currentChatId = chatId;
        this.currentEndpointId = null;
        this.loadUserChats(chat.archived ? "archived" : "active");
        this.displayChatMessages(chat.messages);
      }

      clearCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) {
          this.createNewChat();
          return;
        }

        if (chat.archived) {
          appState.unarchiveChat(
            appState.currentUser.id,
            appState.currentChatId
          );
        }

        this.createNewChat();
      }

      archiveCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) return;

        if (
          confirm(
            "Archive this chat? You can restore it later from the archived tab."
          )
        ) {
          appState.archiveChat(
            appState.currentUser.id,
            appState.currentChatId
          );
          this.createNewChat();
        }
      }

      displayChatMessages(messages) {
        // Clear messages but preserve welcome icon
        const welcomeIcon = document.getElementById('welcome-icon');
        this.chatMessages.innerHTML = "";
        if (welcomeIcon) {
          this.chatMessages.appendChild(welcomeIcon);
        }

        messages.forEach((message) => {
          this.addMessageToUI(
            message.role,
            message.content,
            false,
            message.voiceResponse,
            message.endpointName
          );
        });

        // Hide welcome icon if there are messages
        if (welcomeIcon) {
          welcomeIcon.style.display = messages.length > 0 ? 'none' : 'block';
        }

        this.scrollToBottom();
      }

      clearChatMessages() {
        // Clear messages but preserve welcome icon
        const welcomeIcon = document.getElementById('welcome-icon');
        this.chatMessages.innerHTML = "";
        if (welcomeIcon) {
          this.chatMessages.appendChild(welcomeIcon);
          welcomeIcon.style.display = 'block';
        }
      }

      createMessageElement(role, content, endpointName = null) {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `message-wrapper ${role}`;

        if (role === "system") {
          const systemMessage = document.createElement("div");
          systemMessage.className = "system-message";

          // Check for agent output patterns
          const agentMatch = content.match(/Agent: ([^\n]+)/) || content.match(/Performed (\w+) and got result/);
          if (agentMatch) {
            const agentName = agentMatch[1];
            const uniqueId =
              "agent-output-" + Math.random().toString(36).substr(2, 9);

            const agentWrapper = document.createElement("div");
            agentWrapper.className = "agent-output-wrapper";
            agentWrapper.id = uniqueId;

            agentWrapper.innerHTML = `
              <div class="agent-output-header" onclick="ui.toggleAgentOutput('${uniqueId}')">
                <div class="agent-output-title">
                  <i class="fas fa-robot"></i>
                  <span>Agent: ${agentName}</span>
                </div>
                <button class="agent-output-toggle">
                  <i class="fas fa-chevron-down"></i>
                </button>
              </div>
              <div class="agent-output-content" id="${uniqueId}-content">
                <div class="agent-output-text">${content}</div>
              </div>
            `;

            messageWrapper.appendChild(agentWrapper);
          } else {
            systemMessage.textContent = content;
            messageWrapper.appendChild(systemMessage);
          }
        } else {
          const label = document.createElement("div");
          label.className = "message-label";
          label.innerHTML = role === "user"
            ? "You"
            : `${appState.currentUser.username}'s Digital Twin${endpointName ? `<span class="endpoint-badge"><i class="fas fa-server"></i>${endpointName}</span>` : ''}`;

          const messageContent = document.createElement("div");
          messageContent.className = "message-content";

          if (role === "user" && content.startsWith("data:image")) {
            messageContent.innerHTML = `<img src="${content}" alt="Uploaded image" style="max-width: 100%; border-radius: 8px;">`;
          } else {
            messageContent.innerHTML = this.formatMessage(content);
          }

          messageWrapper.appendChild(label);
          messageWrapper.appendChild(messageContent);
        }

        return messageWrapper;
      }

      toggleAgentOutput(id) {
        const content = document.getElementById(id + "-content");
        const header = document.querySelector(`#${id} .agent-output-header`);
        const toggleIcon = header.querySelector(".agent-output-toggle i");

        if (content.classList.contains("expanded")) {
          content.classList.remove("expanded");
          toggleIcon.className = "fas fa-chevron-down";
        } else {
          content.classList.add("expanded");
          toggleIcon.className = "fas fa-chevron-up";
        }
      }

      addMessageToUI(role, content, animate = true, voiceResponse = null, endpointName = null) {
        const messageWrapper = this.createMessageElement(role, content, endpointName);

        if (role === "assistant" && voiceResponse) {
          const voiceMessage = document.createElement("div");
          voiceMessage.className = "voice-message active";
          voiceMessage.innerHTML = `
            <div class="voice-message-icon">
              <i class="fas fa-volume-up"></i>
            </div>
            <div class="voice-message-content">
              <span>Voice: "${voiceResponse}"</span>
            </div>
          `;

          // Add click handler to toggle expansion
          voiceMessage.addEventListener('click', () => {
            voiceMessage.classList.toggle('expanded');
          });

          messageWrapper.appendChild(voiceMessage);
        }

        this.chatMessages.appendChild(messageWrapper);

        // Hide welcome icon when messages are present
        const welcomeIcon = document.getElementById('welcome-icon');
        if (welcomeIcon) {
          welcomeIcon.style.display = 'none';
        }

        if (role === "assistant" || role === "system") {
          messageWrapper.querySelectorAll("pre code").forEach((block) => {
            hljs.highlightBlock(block);
          });
        }

        if (animate) {
          // Use requestAnimationFrame to ensure DOM has updated before scrolling
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              this.scrollToBottom();
            });
          });
        }
      }

      formatMessage(text) {
        let formattedText = text;

        // Handle @mentions
        formattedText = formattedText.replace(/@(\w+)/g, (match, name) => {
          return `<span class="mention-tag">@${name}</span>`;
        });

        formattedText = formattedText.replace(
          /```(\w+)?\n([\s\S]+?)```/g,
          (match, lang, code) => {
            const language = lang || "plaintext";
            const escapedCode = this.escapeHtml(code.trim());
            return `<pre><code class="${language}">${escapedCode}</code></pre>`;
          }
        );

        formattedText = formattedText.replace(/`([^`]+)`/g, (match, code) => {
          return `<code>${this.escapeHtml(code)}</code>`;
        });

        formattedText = formattedText.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        formattedText = formattedText.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        formattedText = formattedText.replace(
          /\[([^\]]+)\]\(([^)]+)\)/g,
          (match, linkText, url) => {
            return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${linkText}</a></span>`;
          }
        );

        formattedText = formattedText.replace(
          /!\[([^\]]*)\]\(([^)]+)\)/g,
          (match, altText, url) => {
            const displayText = altText || "Image";
            const imageExtensions = ["jpg", "jpeg", "png", "gif", "svg", "webp", "bmp"];
            const urlLower = url.toLowerCase();
            const isImage = imageExtensions.some(
              (ext) =>
                urlLower.includes(`.${ext}`) ||
                urlLower.includes(`/${ext}?`) ||
                urlLower.includes("generated_images")
            );

            if (isImage) {
              return `
                <div style="margin: 10px 0;">
                  <div style="margin-bottom: 5px;">
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary); text-decoration: none;">
                      <i class="fas fa-external-link-alt" style="font-size: 12px;"></i> ${displayText}
                    </a>
                  </div>
                  <img src="${url}"
                       alt="${displayText}"
                       style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: var(--shadow-small); cursor: pointer;"
                       onclick="window.open('${url.replace(/'/g, "\\'")}', '_blank')"
                       onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                  <div style="display: none; padding: 20px; background: var(--gray-20); border-radius: 8px; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="color: var(--warning); font-size: 24px;"></i>
                    <p style="margin: 10px 0 5px 0; color: var(--gray-80);">Unable to load image</p>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">
                      Click here to view image
                    </a>
                  </div>
                </div>
              `;
            } else {
              return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${displayText}</a></span>`;
            }
          }
        );

        formattedText = formattedText.replace(
          /(https?:\/\/[^\s<]+)(?![^<]*>|[^<>]*<\/)/g,
          (match, url) => {
            const imageExtensions = ["jpg", "jpeg", "png", "gif", "svg", "webp", "bmp"];
            const urlLower = url.toLowerCase();
            const isImage = imageExtensions.some(
              (ext) =>
                urlLower.includes(`.${ext}`) ||
                urlLower.includes(`/${ext}?`) ||
                urlLower.includes("generated_images")
            );

            if (isImage) {
              return `
                <div style="margin: 10px 0;">
                  <div style="margin-bottom: 5px;">
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary); text-decoration: none; font-size: 13px; word-break: break-all;">
                      <i class="fas fa-external-link-alt" style="font-size: 12px;"></i> ${url}
                    </a>
                  </div>
                  <img src="${url}"
                       alt="Image"
                       style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: var(--shadow-small); cursor: pointer;"
                       onclick="window.open('${url.replace(/'/g, "\\'")}', '_blank')"
                       onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                  <div style="display: none; padding: 20px; background: var(--gray-20); border-radius: 8px; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="color: var(--warning); font-size: 24px;"></i>
                    <p style="margin: 10px 0 5px 0; color: var(--gray-80);">Unable to load image</p>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">
                      Click here to view image
                    </a>
                  </div>
                </div>
              `;
            } else {
              return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${url}</a></span>`;
            }
          }
        );

        formattedText = formattedText.replace(/\n/g, "<br>");

        return formattedText;
      }

      escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      async sendMessage() {
        const message = this.userInput.value.trim();
        if (!message && !this.pendingImage) return;

        // Check for OS launch commands
        const lowerMsg = message.toLowerCase();
        const osCommands = ['open os', 'launch os', 'collaborative os', 'start workspace', 'open workspace', 'collab os'];
        if (osCommands.some(cmd => lowerMsg.includes(cmd))) {
          this.userInput.value = '';
          this.launchCollaborativeOS();
          return;
        }

        // Check for Agent Store commands
        const storeCommands = ['open store', 'agent store', 'agent marketplace', 'open marketplace', 'browse agents', 'agent shop'];
        if (storeCommands.some(cmd => lowerMsg.includes(cmd))) {
          this.userInput.value = '';
          this.launchAgentStore();
          return;
        }

        // Check for @mentions in message
        const mentionRegex = /@(\w+)/g;
        let targetEndpoint = null;
        const mentions = [];
        let match;

        while ((match = mentionRegex.exec(message)) !== null) {
          mentions.push(match[1]);
        }

        // Find endpoint by mention
        if (mentions.length > 0) {
          const endpoints = Object.values(appState.endpoints);
          targetEndpoint = endpoints.find(ep =>
            mentions.some(mention => ep.name.toLowerCase() === mention.toLowerCase())
          );
        }

        // Use mentioned endpoint, or current endpoint, or active endpoint
        const endpoint = targetEndpoint ||
          (this.currentEndpointId ? appState.getEndpointById(this.currentEndpointId) : null) ||
          appState.getActiveEndpoint();

        if (!endpoint || !endpoint.url) {
          this.openSettings();
          this.showNotification(
            "Please configure at least one endpoint",
            "warning"
          );
          return;
        }

        this.sendButton.disabled = true;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        const userMessage = {
          role: "user",
          content: this.pendingImage || message,
          timestamp: new Date().toISOString(),
        };

        chat.messages.push(userMessage);
        this.addMessageToUI("user", userMessage.content);

        this.userInput.value = "";
        this.userInput.style.height = "auto";
        this.clearImagePreview();

        soundManager.playSendSound();

        this.showLoadingIndicator();

        try {
          // Construct full URL with function key as query parameter
          const fullUrl = endpoint.key
            ? `${endpoint.url}${endpoint.url.includes('?') ? '&' : '?'}code=${endpoint.key}`
            : endpoint.url;

          const response = await fetch(fullUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              user_input: message || "Please analyze this image",
              conversation_history: chat.messages,
              user_guid: endpoint.guid,
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              throw new Error(
                `Invalid function key for ${endpoint.name}. Please check your settings.`
              );
            }
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          this.hideLoadingIndicator();

          const assistantMessage = {
            role: "assistant",
            content:
              data.assistant_response ||
              data.text ||
              "Sorry, I received an empty response.",
            voiceResponse: data.voice_response || null,
            endpointName: endpoint.name,
            timestamp: new Date().toISOString(),
          };

          chat.messages.push(assistantMessage);
          this.addMessageToUI(
            "assistant",
            assistantMessage.content,
            true,
            assistantMessage.voiceResponse,
            assistantMessage.endpointName
          );

          soundManager.playReceiveSound();

          if (appState.settings.autoSpeak && assistantMessage.voiceResponse) {
            await voiceManager.speak(assistantMessage.voiceResponse);
          }

          if (data.agent_logs) {
            const systemMessage = {
              role: "system",
              content: data.agent_logs,
              timestamp: new Date().toISOString(),
            };
            chat.messages.push(systemMessage);
            this.addMessageToUI("system", systemMessage.content);
          }

          chat.updatedAt = new Date().toISOString();
          if (chat.messages.length === 2) {
            chat.title = this.generateChatTitle(message || "Image analysis");
          }

          appState.saveChats();
          this.loadUserChats("active");
        } catch (error) {
          console.error("Error:", error);
          this.hideLoadingIndicator();
          this.addMessageToUI("system", `Error: ${error.message}`);
          soundManager.playNotificationSound();
        } finally {
          this.sendButton.disabled = false;
          this.userInput.focus();
        }
      }

      showLoadingIndicator() {
        const existingLoading = document.getElementById("loading-indicator");
        if (existingLoading) {
          existingLoading.remove();
        }

        const loadingDiv = document.createElement("div");
        loadingDiv.className = "loading active";
        loadingDiv.id = "loading-indicator";
        loadingDiv.innerHTML = `
          <span></span>
          <span></span>
          <span></span>
        `;
        this.chatMessages.appendChild(loadingDiv);
        this.scrollToBottom();
      }

      hideLoadingIndicator() {
        const loadingIndicators = document.querySelectorAll(".loading");
        loadingIndicators.forEach((indicator) => {
          indicator.remove();
        });
      }

      async handleImageUpload(file) {
        if (!file || !file.type.startsWith("image/")) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
          const imageData = e.target.result;
          this.showImagePreview(imageData);

          // Show uploading status
          const uploadStatus = document.createElement('div');
          uploadStatus.className = 'upload-status';
          uploadStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading image to storage...';
          this.imagePreviewContainer.appendChild(uploadStatus);

          try {
            // Step 1: Upload to Azure File Storage
            const endpoint = appState.getActiveEndpoint();
            if (!endpoint || !endpoint.url) {
              throw new Error("Please configure an endpoint first");
            }

            // Construct full URL with function key as query parameter
            const fullUploadUrl = endpoint.key
              ? `${endpoint.url}${endpoint.url.includes('?') ? '&' : '?'}code=${endpoint.key}`
              : endpoint.url;

            const uploadResponse = await fetch(fullUploadUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                user_input: `Please upload this image: ${file.name}`,
                conversation_history: [],
                user_guid: endpoint.guid,
                image_data: imageData
              }),
            });

            if (!uploadResponse.ok) {
              throw new Error(`Upload failed: ${uploadResponse.status}`);
            }

            const uploadData = await uploadResponse.json();
            const responseText = uploadData.assistant_response || "";

            // Extract URL from response
            const urlMatch = responseText.match(/URL:\s*(https?:\/\/[^\s]+)/);
            if (urlMatch && urlMatch[1]) {
              this.pendingImage = urlMatch[1]; // Store the Azure Storage URL
              uploadStatus.innerHTML = '<i class="fas fa-check"></i> Image uploaded successfully!';
              uploadStatus.style.color = '#4ade80';

              // Auto-fill prompt to analyze
              if (!this.userInput.value.trim()) {
                this.userInput.value = 'Please analyze this image';
              }

              setTimeout(() => uploadStatus.remove(), 3000);
            } else {
              throw new Error("Could not extract image URL from upload response");
            }

          } catch (error) {
            console.error("Image upload error:", error);
            uploadStatus.innerHTML = `<i class="fas fa-times"></i> Upload failed: ${error.message}`;
            uploadStatus.style.color = '#ef4444';
            this.pendingImage = imageData; // Fallback to base64
          }
        };
        reader.readAsDataURL(file);
      }

      showImagePreview(imageSrc) {
        this.imagePreviewContainer.innerHTML = `
          <div class="image-preview">
            <img src="${imageSrc}" alt="Preview">
            <button class="image-preview-remove" onclick="ui.clearImagePreview()">
              <i class="fas fa-times"></i>
            </button>
          </div>
        `;
        this.imagePreviewContainer.classList.add("active");
      }

      clearImagePreview() {
        this.pendingImage = null;
        this.imagePreviewContainer.innerHTML = "";
        this.imagePreviewContainer.classList.remove("active");
      }

      exportCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];

        const conversation = chat.messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
        }));

        const endpoint = appState.getActiveEndpoint();

        const exportData = {
          conversation: conversation,
          guid: endpoint.guid,
          timestamp: new Date().toISOString(),
          appName: "_",
        };

        const filename = `conversation-${new Date()
          .toISOString()
          .replace(/:/g, "_")}.json`;
        this.downloadJson(exportData, filename);
      }

      exportAllData() {
        const exportData = appState.exportAllData();
        this.downloadJson(exportData, `chat-app-backup-${Date.now()}.json`);
      }

      exportSettings() {
        const settingsData = appState.exportSettings();
        const timestamp = new Date()
          .toISOString()
          .replace(/:/g, "_")
          .replace(/\..+/, ''); // Remove milliseconds
        const filename = `RAPPID-backup-${timestamp}.json`;
        this.downloadJson(settingsData, filename);
      }

      importSettings(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const settingsData = JSON.parse(e.target.result);

            if (!settingsData.version || (!settingsData.endpoints && !settingsData.azureTTSKey)) {
              throw new Error("Invalid RAPPID backup file format");
            }

            if (!settingsData.rappid) {
              throw new Error("This file is not a valid RAPPID backup");
            }

            appState.importSettings(settingsData);

            this.applySettings();

            if (settingsData.azureTTSKey) {
              voiceManager.setAzureKey(settingsData.azureTTSKey);
            }
            if (settingsData.azureRegion) {
              voiceManager.setAzureRegion(settingsData.azureRegion);
            }
            if (settingsData.ttsVoiceName) {
              voiceManager.setVoiceName(settingsData.ttsVoiceName);
            }

            this.showNotification("RAPPID backup restored successfully!", "success");

            document.getElementById("settings-modal").classList.remove("active");

            this.openSettings();
          } catch (error) {
            this.showNotification(
              "Error restoring RAPPID backup: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      downloadJson(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      importChat(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);

            if (data.conversation && Array.isArray(data.conversation)) {
              const newChat = appState.createChat(appState.currentUser.id,
                "Imported Chat"
              );

              newChat.messages = data.conversation.map((msg) => ({
                role: msg.role,
                content: msg.content,
                timestamp: new Date().toISOString(),
              }));

              newChat.updatedAt = data.timestamp || new Date().toISOString();

              if (newChat.messages.length > 0) {
                const firstUserMessage = newChat.messages.find(
                  (m) => m.role === "user"
                );
                if (firstUserMessage) {
                  newChat.title = this.generateChatTitle(
                    firstUserMessage.content
                  );
                }
              }

              appState.saveChats();
              this.loadChat(newChat.id);
              this.loadUserChats("active");
              this.showNotification("Chat imported successfully!", "success");
            } else if (data.chat && data.chat.messages) {
              const newChat = appState.createChat(
                appState.currentUser.id,
                data.chat.title || "Imported Chat"
              );
              newChat.messages = data.chat.messages;
              newChat.updatedAt = new Date().toISOString();

              appState.saveChats();
              this.loadChat(newChat.id);
              this.loadUserChats("active");
              this.showNotification("Chat imported successfully!", "success");
            } else {
              throw new Error("Invalid chat format");
            }
          } catch (error) {
            this.showNotification(
              "Error importing chat: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      importAllData(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (!data.version || !data.users || !data.chats) {
              throw new Error("Invalid backup format");
            }

            if (
              confirm(
                "This will merge the imported data with your existing data. Continue?"
              )
            ) {
              appState.importAllData(data);
              this.showNotification(
                "Data imported successfully! Please login again.",
                "success"
              );
              this.logout();
            }
          } catch (error) {
            this.showNotification(
              "Error importing data: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      handleJsonImport(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            
            // Check for test script formats
            if (data.testScript || (Array.isArray(data) && data.length > 0 && typeof data[0] === 'string')) {
              // Test script detected
              testRunner.load(data);
            } else if (data.messages && Array.isArray(data.messages)) {
              // Could be chat export or test script - check for user messages
              const userMessages = data.messages.filter(m => m.role === 'user');
              if (userMessages.length > 0) {
                const isTestScript = confirm('This looks like a chat export.\n\nClick OK to load as Test Script (replay user messages)\nClick Cancel to import as Chat History');
                if (isTestScript) {
                  testRunner.load(data);
                } else {
                  this.importChat(file);
                }
              } else {
                this.importChat(file);
              }
            } else if (data.conversation || (data.chat && data.user)) {
              this.importChat(file);
            } else if (data.users && data.chats) {
              this.importAllData(file);
            } else if (data.endpoint || data.url) {
              // RAPPid.json format - trigger onboarding import
              document.getElementById('onboarding-endpoint-name').value = data.name || data.endpoint?.name || 'Imported Endpoint';
              document.getElementById('onboarding-endpoint-url').value = data.url || data.endpoint?.url || '';
              document.getElementById('onboarding-endpoint-key').value = data.key || data.endpoint?.key || '';
              openOnboardingModal();
              showOnboardingStep('3');
              this.showNotification("RAPPid.json imported - review and save", "success");
            } else {
              this.showNotification("Unknown file format", "error");
            }
          } catch (error) {
            this.showNotification(
              "Error reading file: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      generateChatTitle(firstMessage) {
        const cleanMessage = firstMessage
          .replace(/[^\w\s]/g, "")
          .toLowerCase();
        const words = cleanMessage.split(" ").filter((w) => w.length > 3);

        if (words.length > 3) {
          return words.slice(0, 3).join(" ");
        } else if (firstMessage.length > 30) {
          return firstMessage.substring(0, 30) + "...";
        } else {
          return firstMessage;
        }
      }

      toggleTheme() {
        const isDark = document.body.classList.toggle("dark");
        appState.settings.theme = isDark ? "dark" : "light";
        appState.saveSettings();

        const themeIcon = document.querySelector("#theme-toggle i");
        themeIcon.className = isDark ? "fas fa-sun" : "fas fa-moon";

        const darkModeToggle = document.getElementById("dark-mode-toggle");
        if (darkModeToggle) {
          darkModeToggle.classList.toggle("active", isDark);
        }
      }

      applyTheme() {
        if (appState.settings.theme === "dark") {
          document.body.classList.add("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-sun";
        }
      }

      saveAllSettings() {
        const isDarkMode = document
          .getElementById("dark-mode-toggle")
          .classList.contains("active");
        appState.settings.theme = isDarkMode ? "dark" : "light";

        if (isDarkMode && !document.body.classList.contains("dark")) {
          document.body.classList.add("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-sun";
        } else if (!isDarkMode && document.body.classList.contains("dark")) {
          document.body.classList.remove("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-moon";
        }

        appState.settings.soundEnabled = document
          .getElementById("sound-toggle")
          .classList.contains("active");
        soundManager.setEnabled(appState.settings.soundEnabled);

        appState.settings.voiceEnabled = document
          .getElementById("voice-enabled-toggle")
          .classList.contains("active");
        appState.settings.autoSpeak = document
          .getElementById("auto-speak-toggle")
          .classList.contains("active");

        voiceManager.setEnabled(appState.settings.voiceEnabled);
        voiceManager.setAutoSpeak(appState.settings.autoSpeak);

        const azureTTSKey = document
          .getElementById("azure-tts-key")
          .value.trim();
        appState.settings.azureTTSKey = azureTTSKey;
        voiceManager.setAzureKey(azureTTSKey);

        const azureRegion = document.getElementById("azure-region-select").value;
        appState.settings.azureRegion = azureRegion;
        voiceManager.setAzureRegion(azureRegion);

        const ttsVoice = document.getElementById("tts-voice-select").value;
        appState.settings.ttsVoiceName = ttsVoice;
        voiceManager.setVoiceName(ttsVoice);

        appState.saveSettings();

        this.showNotification("Settings saved successfully!", "success");
        document.getElementById("settings-modal").classList.remove("active");
      }

      applySettings() {
        this.applyTheme();

        soundManager.setEnabled(appState.settings.soundEnabled);

        voiceManager.setEnabled(appState.settings.voiceEnabled);
        voiceManager.setAutoSpeak(appState.settings.autoSpeak);
        voiceManager.setAzureKey(appState.settings.azureTTSKey);
        voiceManager.setAzureRegion(appState.settings.azureRegion || "eastus2");
        voiceManager.setVoiceName(appState.settings.ttsVoiceName);

        const darkModeToggle = document.getElementById("dark-mode-toggle");
        if (darkModeToggle) {
          darkModeToggle.classList.toggle(
            "active",
            appState.settings.theme === "dark"
          );
        }

        const soundToggle = document.getElementById("sound-toggle");
        if (soundToggle) {
          soundToggle.classList.toggle(
            "active",
            appState.settings.soundEnabled
          );
        }

        const voiceEnabledToggle = document.getElementById(
          "voice-enabled-toggle"
        );
        if (voiceEnabledToggle) {
          voiceEnabledToggle.classList.toggle(
            "active",
            appState.settings.voiceEnabled
          );
        }

        const autoSpeakToggle = document.getElementById("auto-speak-toggle");
        if (autoSpeakToggle) {
          autoSpeakToggle.classList.toggle(
            "active",
            appState.settings.autoSpeak
          );
        }

        const azureTTSKeyInput = document.getElementById("azure-tts-key");
        if (azureTTSKeyInput && appState.settings.azureTTSKey) {
          azureTTSKeyInput.value = appState.settings.azureTTSKey;
        }

        const azureRegionSelect = document.getElementById("azure-region-select");
        if (azureRegionSelect) {
          azureRegionSelect.value = appState.settings.azureRegion || "eastus2";
        }

        const ttsVoiceSelect = document.getElementById("tts-voice-select");
        if (ttsVoiceSelect) {
          ttsVoiceSelect.value = appState.settings.ttsVoiceName;
        }

        this.loadEndpointList();
      }

      openSettings() {
        this.applySettings();
        document.getElementById("settings-modal").classList.add("active");
      }

      openTimeMachine() {
        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) {
          this.showNotification(
            "No messages to replay in the current chat.",
            "info"
          );
          return;
        }

        document.getElementById("time-machine-modal").classList.add("active");
        document
          .getElementById("time-machine-controls")
          .classList.add("hidden");
      }

      closeMenu() {
        document.getElementById("menu-toggle").classList.remove("active");
        document.getElementById("menu-items").classList.remove("open");
      }

      scrollToBottom() {
        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
      }

      truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + "...";
      }

      formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return "Just now";
        if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
        if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
        if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;

        return date.toLocaleDateString();
      }

      showNotification(message, type = "info") {
        const notification = document.createElement("div");
        notification.className = `notification notification-${type}`;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === "success"
            ? "var(--success)"
            : type === "error"
              ? "var(--error)"
              : type === "warning"
                ? "var(--warning)"
                : "var(--info)"
          };
          color: white;
          padding: 16px 24px;
          border-radius: var(--radius);
          box-shadow: var(--shadow-large);
          z-index: 2000;
          animation: slideUp 0.3s ease-out;
          max-width: 320px;
        `;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.animation = "fadeOut 0.3s ease-out";
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 300);
        }, 3000);
      }
    }

    // Initialize UI Controller
    const ui = new UIController();

    // Make UI instance globally accessible for inline event handlers
    window.ui = ui;

    // Initialize sound manager with saved settings
    soundManager.setEnabled(appState.settings.soundEnabled);

    // Initialize voice manager with saved settings
    voiceManager.setEnabled(appState.settings.voiceEnabled);
    voiceManager.setAutoSpeak(appState.settings.autoSpeak);
    voiceManager.setAzureKey(appState.settings.azureTTSKey);
    voiceManager.setAzureRegion(appState.settings.azureRegion || "eastus2");
    voiceManager.setVoiceName(appState.settings.ttsVoiceName);

    // Add keyboard navigation support
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        const modals = document.querySelectorAll(".modal.active");
        modals.forEach((modal) => {
          modal.classList.remove("active");
        });

        if (
          document.getElementById("menu-items").classList.contains("open")
        ) {
          ui.closeMenu();
        }

        if (document.getElementById("sidebar").classList.contains("open")) {
          ui.toggleSidebar();
        }
      }

      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        document.getElementById("user-input").focus();
      }

      if ((e.metaKey || e.ctrlKey) && e.key === "n") {
        e.preventDefault();
        ui.createNewChat();
      }
    });

    // Add fade out animation
    const style = document.createElement("style");
    style.textContent = `
      @keyframes fadeOut {
        to {
          opacity: 0;
          transform: translateY(-20px);
        }
      }
    `;
    document.head.appendChild(style);

    // Force load voices for speech synthesis
    if ("speechSynthesis" in window) {
      speechSynthesis.getVoices();
      window.speechSynthesis.onvoiceschanged = () => {
        speechSynthesis.getVoices();
      };
    }

    // ========================================
    // Split View Manager
    // ========================================
    class SplitViewController {
      constructor() {
        this.splitViewTool = document.getElementById('split-view-tool');
        this.splitViewDivider = document.getElementById('split-view-divider');
        this.splitViewMain = document.querySelector('.split-view-main');
        this.splitViewIframe = document.getElementById('split-view-tool-iframe');
        this.splitViewToolName = document.getElementById('split-view-tool-name');
        this.toolGalleryModal = document.getElementById('tool-gallery-modal');
        this.toolGalleryGrid = document.getElementById('tool-gallery-grid');
        this.toolGallerySearchInput = document.getElementById('tool-gallery-search-input');

        this.isDragging = false;
        this.isFullscreen = false;
        this.currentTool = null;
        this.tools = [];

        this.init();
      }

      init() {
        // Load saved state
        this.loadState();

        // Load tools from localFirstTools
        this.loadTools();

        // Setup event listeners
        this.setupEventListeners();

        // Restore pinned tool if any
        if (this.currentTool) {
          this.pinTool(this.currentTool);
        }
      }

      loadState() {
        const savedState = localStorage.getItem('splitViewState');
        if (savedState) {
          const state = JSON.parse(savedState);
          this.currentTool = state.currentTool;
          if (state.splitRatio) {
            this.splitViewMain.style.flex = state.splitRatio;
          }
        }
      }

      saveState() {
        const state = {
          currentTool: this.currentTool,
          splitRatio: this.splitViewMain.style.flex || '1'
        };
        localStorage.setItem('splitViewState', JSON.stringify(state));
      }

      async loadTools() {
        this.tools = this.getDefaultTools();
        this.renderToolGallery();
      }

      getDefaultTools() {
        return [
          { name: 'Todo List', path: 'localFirstTools/productivity/todo-list.html', icon: 'fa-tasks' },
          { name: 'Note Taking', path: 'localFirstTools/productivity/note-taking.html', icon: 'fa-sticky-note' },
          { name: 'Calculator', path: 'localFirstTools/utilities/calculator.html', icon: 'fa-calculator' },
          { name: 'Timer', path: 'localFirstTools/utilities/timer.html', icon: 'fa-clock' },
          { name: 'Code Editor', path: 'localFirstTools/development/code-editor.html', icon: 'fa-code' },
          { name: 'Markdown Editor', path: 'localFirstTools/development/markdown-editor.html', icon: 'fa-markdown' }
        ];
      }

      getIconForTool(name, category = '') {
        // Category-specific default icons
        const categoryIcons = {
          'ai-tools': 'fa-robot',
          'games': 'fa-gamepad',
          'productivity': 'fa-tasks',
          'business': 'fa-briefcase',
          'development': 'fa-code',
          'media': 'fa-video',
          'education': 'fa-graduation-cap',
          'health': 'fa-heartbeat',
          'utilities': 'fa-wrench',
          'quantum-worlds': 'fa-globe',
          'index-variants': 'fa-th'
        };

        // Keyword-based icon mapping
        const iconMap = {
          'ai': 'fa-robot',
          'chat': 'fa-comments',
          'assistant': 'fa-user-robot',
          'neural': 'fa-brain',
          'game': 'fa-gamepad',
          'todo': 'fa-tasks',
          'note': 'fa-sticky-note',
          'calculator': 'fa-calculator',
          'timer': 'fa-clock',
          'code': 'fa-code',
          'editor': 'fa-edit',
          'markdown': 'fa-markdown',
          'calendar': 'fa-calendar',
          'budget': 'fa-dollar-sign',
          'password': 'fa-key',
          'vault': 'fa-lock',
          'chart': 'fa-chart-bar',
          'drawing': 'fa-palette',
          'paint': 'fa-paint-brush',
          'video': 'fa-video',
          'audio': 'fa-music',
          'music': 'fa-music',
          'quantum': 'fa-atom',
          'particle': 'fa-atom',
          'physics': 'fa-flask',
          'browser': 'fa-browser',
          'os': 'fa-desktop',
          'terminal': 'fa-terminal',
          'book': 'fa-book',
          'journal': 'fa-book',
          'presentation': 'fa-presentation',
          'email': 'fa-envelope',
          'crm': 'fa-users',
          'dashboard': 'fa-tachometer-alt'
        };

        const lowerName = name.toLowerCase();

        // First check name-based keywords
        for (const [key, icon] of Object.entries(iconMap)) {
          if (lowerName.includes(key)) {
            return icon;
          }
        }

        // Fall back to category icon
        if (category && categoryIcons[category]) {
          return categoryIcons[category];
        }

        return 'fa-cube';
      }

      renderToolGallery() {
        this.toolGalleryGrid.innerHTML = '';

        const searchTerm = this.toolGallerySearchInput.value.toLowerCase();
        const filteredTools = this.tools.filter(tool =>
          tool.name.toLowerCase().includes(searchTerm) ||
          (tool.category && tool.category.toLowerCase().includes(searchTerm))
        );

        // Show count
        if (searchTerm) {
          console.log(`Showing ${filteredTools.length} of ${this.tools.length} tools`);
        }

        filteredTools.forEach(tool => {
          const toolItem = document.createElement('div');
          toolItem.className = 'tool-gallery-item';
          const categoryDisplay = tool.category ? tool.category.replace('-', ' ') : '';
          toolItem.innerHTML = `
            <div class="tool-gallery-item-icon">
              <i class="fas ${tool.icon}"></i>
            </div>
            <div class="tool-gallery-item-name">${tool.name}</div>
            <div class="tool-gallery-item-desc">${categoryDisplay}</div>
          `;
          toolItem.addEventListener('click', () => {
            this.pinTool(tool);
            this.closeToolGallery();
          });
          this.toolGalleryGrid.appendChild(toolItem);
        });
      }

      setupEventListeners() {
        // Pin tool button
        document.getElementById('pin-tool-button')?.addEventListener('click', () => {
          this.openToolGallery();
        });

        // Tool gallery close
        document.getElementById('tool-gallery-close')?.addEventListener('click', () => {
          this.closeToolGallery();
        });

        // Close modal on backdrop click
        this.toolGalleryModal?.addEventListener('click', (e) => {
          if (e.target === this.toolGalleryModal) {
            this.closeToolGallery();
          }
        });

        // Tool gallery search
        this.toolGallerySearchInput?.addEventListener('input', () => {
          this.renderToolGallery();
        });

        // Close tool button
        document.getElementById('split-view-close')?.addEventListener('click', () => {
          this.closeTool();
        });

        // Refresh tool button
        document.getElementById('split-view-refresh')?.addEventListener('click', () => {
          this.refreshTool();
        });

        // Fullscreen button
        document.getElementById('split-view-fullscreen').addEventListener('click', () => {
          this.toggleFullscreen();
        });

        // Divider drag
        this.splitViewDivider.addEventListener('mousedown', (e) => {
          this.startDragging(e);
        });

        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            this.onDrag(e);
          }
        });

        document.addEventListener('mouseup', () => {
          this.stopDragging();
        });

        // Escape to close tool gallery
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.toolGalleryModal.classList.contains('active')) {
            this.closeToolGallery();
          }
        });
      }

      openToolGallery() {
        this.toolGalleryModal.classList.add('active');
        this.toolGallerySearchInput.value = '';
        this.renderToolGallery();
        this.toolGallerySearchInput.focus();
      }

      closeToolGallery() {
        this.toolGalleryModal.classList.remove('active');
      }

      launchCollaborativeOS() {
        // Open Collaborative OS in new window
        const osWindow = window.open(
          'localFirstTools/apps/ai-tools/collaborative-ai-os.html',
          'CollaborativeOS',
          'width=1200,height=800,menubar=no,toolbar=no,location=no,status=no'
        );

        // Add notification message to chat
        const message = {
          role: 'assistant',
          content: ` **Collaborative AI OS Launched!**\n\nI've opened the shared workspace environment where we can collaborate in real-time.\n\n**What you can do:**\n- **Command Center**: Send me commands that I'll execute\n- **Activity Feed**: Watch my actions as they happen\n- **Terminal**: Run commands together\n- **File Manager**: Share files between us\n- **AI Chat**: Talk to me directly in the OS\n\n**Try these commands in the OS:**\n- "open terminal"\n- "system status"\n- "show activity"\n- "list files"\n\nThe OS should be opening in a new window now. I'll be waiting there! `
        };

        // Add message to current conversation
        this.addMessageToUI(message);

        // Close tool gallery if open
        if (this.toolGalleryModal.classList.contains('active')) {
          this.closeToolGallery();
        }

        // Track analytics if available
        if (typeof gtag !== 'undefined') {
          gtag('event', 'launch_collaborative_os', {
            'event_category': 'engagement',
            'event_label': 'header_button'
          });
        }
      }

      launchAgentStore() {
        // Open Agent Store in new window
        const storeWindow = window.open(
          'agent_store.html',
          'AgentStore',
          'width=1400,height=900,menubar=no,toolbar=no,location=no,status=no'
        );

        // Add notification message to chat
        const message = {
          role: 'assistant',
          content: ` **Agent Marketplace Opened!**\n\nBrowse and download AI agents from the marketplace.\n\n**What you'll find:**\n- ** Pre-built Agents**: Ready-to-use AI agents for various tasks\n- ** Agent Stacks**: Complete solutions with multiple agents\n- ** Demo Apps**: Interactive demonstrations\n- ** Documentation**: Setup guides and examples\n- ** Custom Agents**: Upload and manage your own agents\n\n**Popular Categories:**\n- B2B Sales (Account Intelligence, Deal Progression)\n- Customer Service (Support Bot, Sentiment Analysis)\n- Development (Code Assistant, Documentation Generator)\n- Business Intelligence (Analytics, Reporting)\n\n**How to use:**\n1. Browse the catalog\n2. Add agents to your cart\n3. Export download script\n4. Run script to install agents\n5. Restart RAPP to load new agents\n\nThe marketplace is opening now! `
        };

        // Add message to current conversation
        this.addMessageToUI(message);

        // Close tool gallery if open
        if (this.toolGalleryModal.classList.contains('active')) {
          this.closeToolGallery();
        }

        // Track analytics if available
        if (typeof gtag !== 'undefined') {
          gtag('event', 'launch_agent_store', {
            'event_category': 'engagement',
            'event_label': 'header_button'
          });
        }
      }

      // Live Order Taking Methods
      openLiveOrder() {
        // Check if Azure Speech is configured
        if (!voiceManager.azureKey || !voiceManager.isSdkLoaded) {
          this.showNotification(
            'Azure Speech API key required. Please configure in Settings.',
            'error'
          );
          return;
        }

        // Initialize live order state
        this.liveOrderState = {
          fullTranscript: '',
          currentOrder: [],
          total: 0,
          isActive: true
        };

        // Open modal
        document.getElementById('live-order-modal').classList.add('active');

        // Reset UI
        document.getElementById('live-order-transcript').innerHTML =
          '<span style="color: var(--gray-80); font-style: italic;">Listening... speak your order now</span>';
        document.getElementById('live-order-feedback').innerHTML =
          '<span style="color: var(--gray-80); font-style: italic;">AI listening for order details...</span>';
        document.getElementById('live-order-summary').innerHTML =
          '<div style="color: var(--gray-80); font-style: italic;">No items yet...</div>';
        document.getElementById('live-order-total').textContent = '0.00';

        // Start continuous listening
        voiceManager.startContinuousListening(
          // Interim callback (while speaking)
          (fullTranscript, interimText) => {
            this.updateLiveOrderTranscript(fullTranscript, interimText, true);
          },
          // Final callback (phrase complete)
          (fullTranscript, finalText) => {
            this.updateLiveOrderTranscript(fullTranscript, finalText, false);
            this.analyzeLiveOrder(fullTranscript);
          },
          // Error callback
          (error) => {
            console.error('Live order error:', error);
            this.showNotification('Speech recognition error: ' + error, 'error');
          }
        );

        soundManager.playReceiveSound();
      }

      updateLiveOrderTranscript(fullTranscript, latestText, isInterim) {
        const transcriptEl = document.getElementById('live-order-transcript');

        if (isInterim) {
          // Show interim results in gray
          transcriptEl.innerHTML = `${fullTranscript}<span style="color: var(--gray-60); font-style: italic;">${latestText}</span>`;
        } else {
          // Show final results
          transcriptEl.textContent = fullTranscript;
          this.liveOrderState.fullTranscript = fullTranscript;
        }

        // Auto-scroll to bottom
        transcriptEl.scrollTop = transcriptEl.scrollHeight;
      }

      async analyzeLiveOrder(transcript) {
        if (!transcript || !this.liveOrderState.isActive) return;

        try {
          // Show analyzing status
          const feedbackEl = document.getElementById('live-order-feedback');
          feedbackEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing order...';

          // Call order verification agent
          const endpoint = appState.endpoints[appState.activeEndpoint];
          const fullOrderUrl = endpoint.key
            ? `${endpoint.url}${endpoint.url.includes('?') ? '&' : '?'}code=${endpoint.key}`
            : endpoint.url;

          const response = await fetch(fullOrderUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              user_input: `@OrderVerification customer_input="${transcript}" business_type="fast_food" enable_upsell=true`,
              conversation_history: [],
              user_guid: appState.currentUser.id
            })
          });

          if (!response.ok) {
            throw new Error('Failed to analyze order');
          }

          const data = await response.json();

          // Extract order analysis from response
          this.updateLiveOrderUI(data.assistant_response);

        } catch (error) {
          console.error('Order analysis error:', error);
          const feedbackEl = document.getElementById('live-order-feedback');
          feedbackEl.innerHTML = '<span style="color: var(--error);"> Could not analyze order. Please try again.</span>';
        }
      }

      updateLiveOrderUI(agentResponse) {
        if (!agentResponse) return;

        // Update feedback section with agent response
        const feedbackEl = document.getElementById('live-order-feedback');

        // Parse the markdown response
        const feedbackHTML = marked.parse(agentResponse);
        feedbackEl.innerHTML = feedbackHTML;

        // Extract order items and total from response
        this.extractOrderDetails(agentResponse);

        // Auto-scroll feedback
        feedbackEl.scrollTop = feedbackEl.scrollHeight;
      }

      extractOrderDetails(response) {
        // Extract items from the response (parse the markdown)
        const summaryEl = document.getElementById('live-order-summary');
        const totalEl = document.getElementById('live-order-total');

        // Look for "I heard you order:" section
        const orderMatch = response.match(/\*\*I heard you order:\*\*([\s\S]*?)(?=\*\*|$)/);
        if (orderMatch) {
          const orderText = orderMatch[1].trim();
          summaryEl.innerHTML = orderText.replace(/^- /gm, ' ');
        }

        // Extract total
        const totalMatch = response.match(/\*\*Current Total: \$(\d+\.\d{2})\*\*/);
        if (totalMatch) {
          totalEl.textContent = totalMatch[1];
          this.liveOrderState.total = parseFloat(totalMatch[1]);
        }
      }

      closeLiveOrder() {
        // Stop listening
        voiceManager.stopContinuousListening();

        // Close modal
        document.getElementById('live-order-modal').classList.remove('active');

        // Mark as inactive
        if (this.liveOrderState) {
          this.liveOrderState.isActive = false;
        }

        soundManager.playSendSound();
      }

      cancelLiveOrder() {
        // Confirm cancellation
        if (this.liveOrderState && this.liveOrderState.total > 0) {
          const confirmed = confirm('Are you sure you want to cancel this order?');
          if (!confirmed) return;
        }

        this.closeLiveOrder();
        this.showNotification('Order cancelled', 'info');
      }

      async confirmLiveOrder() {
        if (!this.liveOrderState || !this.liveOrderState.fullTranscript) {
          this.showNotification('No order to confirm', 'error');
          return;
        }

        // Stop listening
        voiceManager.stopContinuousListening();

        // Create order summary message
        const orderMessage = {
          role: 'user',
          content: ` Order placed: ${this.liveOrderState.fullTranscript}`
        };

        // Create confirmation message
        const confirmMessage = {
          role: 'assistant',
          content: ` **Order Confirmed!**\n\n**Total: $${this.liveOrderState.total.toFixed(2)}**\n\n${document.getElementById('live-order-summary').innerText}\n\nYour order has been placed successfully. Order number: #${Math.floor(Math.random() * 10000)}\n\n*Thank you for your order!*`
        };

        // Add messages to chat
        this.addMessageToUI(orderMessage);
        this.addMessageToUI(confirmMessage);

        // Save to chat history
        const currentChat = appState.chats[appState.currentChatId];
        if (currentChat) {
          currentChat.messages.push(orderMessage);
          currentChat.messages.push(confirmMessage);
          currentChat.updatedAt = new Date().toISOString();
          appState.saveChats();
        }

        // Close modal
        document.getElementById('live-order-modal').classList.remove('active');

        // Show success notification
        this.showNotification('Order confirmed successfully!', 'success');
        soundManager.playReceiveSound();

        // Speak confirmation if enabled
        if (voiceManager.enabled && voiceManager.autoSpeak) {
          voiceManager.speak(`Order confirmed. Total is $${this.liveOrderState.total.toFixed(2)}. Thank you!`);
        }
      }

      pinTool(tool) {
        this.currentTool = tool;
        this.splitViewTool.classList.add('active');
        this.splitViewToolName.textContent = tool.name;
        this.splitViewIframe.src = tool.path;
        this.saveState();
      }

      closeTool() {
        this.splitViewTool.classList.remove('active');
        this.splitViewIframe.src = '';
        this.currentTool = null;
        this.isFullscreen = false;
        this.splitViewMain.style.display = '';
        this.splitViewDivider.style.display = '';
        document.getElementById('split-view-fullscreen').querySelector('i').className = 'fas fa-expand';
        this.saveState();
      }

      refreshTool() {
        if (this.currentTool) {
          this.splitViewIframe.src = this.splitViewIframe.src;
        }
      }

      toggleFullscreen() {
        this.isFullscreen = !this.isFullscreen;
        if (this.isFullscreen) {
          this.splitViewMain.style.display = 'none';
          this.splitViewDivider.style.display = 'none';
          document.getElementById('split-view-fullscreen').querySelector('i').className = 'fas fa-compress';
        } else {
          this.splitViewMain.style.display = '';
          this.splitViewDivider.style.display = '';
          document.getElementById('split-view-fullscreen').querySelector('i').className = 'fas fa-expand';
        }
      }

      startDragging(e) {
        this.isDragging = true;
        e.preventDefault();
      }

      onDrag(e) {
        if (!this.isDragging) return;

        const container = document.querySelector('.split-view-container');
        const containerRect = container.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const containerWidth = containerRect.width;

        // Calculate flex values
        const mainWidth = mouseX;
        const toolWidth = containerWidth - mouseX - 4; // 4px for divider

        // Minimum width constraints (300px)
        if (mainWidth >= 300 && toolWidth >= 300) {
          const mainFlex = mainWidth / containerWidth;
          const toolFlex = toolWidth / containerWidth;

          this.splitViewMain.style.flex = mainFlex.toFixed(3);
          this.splitViewTool.style.flex = toolFlex.toFixed(3);
        }
      }

      stopDragging() {
        if (this.isDragging) {
          this.isDragging = false;
          this.saveState();
        }
      }
    }

    // Initialize Split View Controller
    const splitViewController = new SplitViewController();

    // Make it globally accessible if needed
    window.splitViewController = splitViewController;
  </script>

  <!-- DISTRIBUTED P2P MESH NETWORK SYSTEM - INLINED FOR LOCAL FILE OPERATION -->
  <script>
/**
 * DISTRIBUTED RAPP MESH NETWORK
 *
 * A true peer-to-peer distributed state management system where ALL browser
 * instances (Chrome, Firefox, Safari, Edge) form a collaborative mesh network
 * to maintain synchronized RAPP state with eventual consistency.
 *
 * Architecture:
 * - WebRTC P2P mesh: All browsers connect to each other
 * - Distributed state: State is replicated across all nodes
 * - CRDTs: Conflict-free state merging
 * - Operation log: Track all state changes
 * - Vector clocks: Determine causality
 * - Gossip protocol: Efficient state propagation
 * - Quorum consensus: Agreement on state changes
 * - Partition tolerance: Handles network splits
 *
 * Features:
 * - Real-time sync: Changes propagate instantly
 * - Offline support: Continue working during disconnects
 * - Conflict resolution: Automatic merge of concurrent edits
 * - Distributed search: Query across all nodes
 * - Load balancing: Distribute compute across browsers
 * - Fault tolerance: Survive node failures
 */

/**
 * Show Mode Manager - Cross-Device P2P Synchronization via PeerJS
 * Enables RAPPID sync across different browsers and devices using QR codes
 */
class ShowModeManager {
  constructor(rappMesh) {
    this.rappMesh = rappMesh;
    this.peer = null;
    this.connections = new Map(); // peerId -> connection
    this.isHost = false;
    this.roomId = null;
    this.isFollowing = false;
    this.isHooked = false; // Track if we've hooked into mesh
    this.connectionTimeout = null; // Timeout for peer connection

    this.initializePeer();
    this.setupEventListeners();
  }

  initializePeer() {
    // Check if PeerJS is available
    if (typeof Peer === 'undefined') {
      console.error('[Show Mode] PeerJS library not loaded!');
      return;
    }

    // Show "Connecting..." state on welcome screen
    this.showConnectingState();

    // Check if joining an existing session
    const urlParams = new URLSearchParams(window.location.search);
    const hostId = urlParams.get('mesh');

    try {
      if (hostId) {
        // Joining as viewer
        this.roomId = hostId;
        this.peer = new Peer();
        this.isFollowing = true;

        this.peer.on('open', (id) => {
          console.log('[Show Mode] Viewer peer ID:', id);
          console.log('[Show Mode] Connecting to host:', this.roomId);

          setTimeout(() => {
            this.connectToHost(this.roomId);
          }, 1000);
        });
      } else {
        // Normal mode - automatically start hosting (sharing enabled by default)
        console.log('[Show Mode] Initializing peer for auto-hosting...');
        this.peer = new Peer({
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:global.stun.twilio.com:3478' }
            ]
          },
          debug: 1 // Show debug info in console
        });

        this.peer.on('open', (id) => {
          console.log('[Show Mode]  Peer ID ready:', id);

          // Clear connection timeout since peer is ready
          if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = null;
          }

          // Automatically start hosting and show QR code
          console.log('[Show Mode] Auto-starting hosting in 500ms...');
          setTimeout(() => {
            this.startHosting();
          }, 500);
        });
      }

      // Handle incoming connections
      this.peer.on('connection', (conn) => {
        console.log('[Show Mode] Incoming connection from:', conn.peer);
        this.handleNewConnection(conn);
      });

      // Handle errors
      this.peer.on('error', (err) => {
        console.error('[Show Mode] Peer error:', err);
        this.showNotification('Connection error: ' + err.message);
      });

    } catch (error) {
      console.error('[Show Mode] Failed to initialize peer:', error);
    }
  }

  setupEventListeners() {
    // Share button in mesh banner
    document.getElementById('mesh-banner-share')?.addEventListener('click', () => {
      this.startHosting(true); // Show modal when button is clicked
    });

    // Close modal
    document.getElementById('show-mode-close-btn')?.addEventListener('click', () => {
      document.getElementById('show-mode-modal').style.display = 'none';
    });

    // Copy URL button
    document.getElementById('copy-share-url')?.addEventListener('click', async () => {
      const urlInput = document.getElementById('share-url');
      try {
        await navigator.clipboard.writeText(urlInput.value);
        const btn = document.getElementById('copy-share-url');
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
        setTimeout(() => {
          btn.innerHTML = originalHtml;
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });
  }

  startHosting(showModal = false) {
    console.log('[Show Mode] startHosting called, showModal:', showModal);
    console.log('[Show Mode] peer:', this.peer ? 'exists' : 'null');
    console.log('[Show Mode] peer.id:', this.peer?.id || 'not ready');

    if (!this.peer || !this.peer.id) {
      console.log('[Show Mode] Peer not ready, retrying in 1 second...');
      this.showNotification('Please wait, connecting to P2P network...');
      setTimeout(() => this.startHosting(showModal), 1000);
      return;
    }

    // If already hosting, just show modal if requested
    if (this.isHost && this.roomId) {
      console.log('[Show Mode] Already hosting, roomId:', this.roomId);
      if (showModal) {
        document.getElementById('show-mode-modal').style.display = 'flex';
        this.showNotification(' Sharing enabled! Scan QR code to join from another device');
      }
      return;
    }

    console.log('[Show Mode] Starting hosting mode...');
    this.isHost = true;
    this.roomId = this.peer.id;

    // Generate share URL
    const shareUrl = `${window.location.origin}${window.location.pathname}?mesh=${this.roomId}`;
    console.log('[Show Mode] Share URL:', shareUrl);

    // Show welcome icon with QR code if chat is empty
    console.log('[Show Mode] Calling showWelcomeQRCode...');
    this.showWelcomeQRCode(shareUrl);

    // Update share URL in modal (but don't show modal unless requested)
    document.getElementById('show-mode-status').style.display = 'block';
    document.getElementById('share-url').value = shareUrl;

    // Generate QR code in modal
    this.generateQRCode(shareUrl);

    // Update viewer count
    this.updateViewerCount();

    // Only show modal if explicitly requested (e.g., button click)
    if (showModal) {
      document.getElementById('show-mode-modal').style.display = 'flex';
      this.showNotification(' Sharing enabled! Scan QR code to join from another device');
    }

    // Hook into rappMesh to broadcast operations
    this.hookIntoMesh();
  }

  connectToHost(hostId) {
    try {
      console.log('[Show Mode] Connecting to host:', hostId);

      const conn = this.peer.connect(hostId, {
        reliable: true,
        serialization: 'json'
      });

      conn.on('open', () => {
        console.log('[Show Mode] Connected to host successfully!');
        this.showNotification(' Connected! Following host\'s RAPP state');
      });

      this.handleNewConnection(conn);
    } catch (error) {
      console.error('[Show Mode] Failed to connect to host:', error);
      this.showNotification('Failed to connect to host');
    }
  }

  handleNewConnection(conn) {
    const peerId = conn.peer;

    conn.on('open', () => {
      console.log('[Show Mode] Connection opened with peer:', peerId);
      this.connections.set(peerId, conn);

      if (this.isHost) {
        this.updateViewerCount();
        this.showNotification(`New device connected: ${peerId.substring(0, 8)}...`);

        // Send current state to new peer
        this.sendFullState(conn);
      }
    });

    conn.on('data', (data) => {
      this.handlePeerData(peerId, data);
    });

    conn.on('close', () => {
      console.log('[Show Mode] Peer disconnected:', peerId);
      this.connections.delete(peerId);

      if (this.isHost) {
        this.updateViewerCount();
      }
    });

    conn.on('error', (err) => {
      console.error('[Show Mode] Connection error with peer', peerId, ':', err);
    });
  }

  handlePeerData(peerId, data) {
    try {
      if (data.type === 'operation') {
        // Received mesh operation from peer
        console.log('[Show Mode] Received operation from peer:', data.operation.type);

        if (!this.isHost) {
          // Apply operation from host
          this.rappMesh.applyRemoteOperation(data.operation);
        }
      } else if (data.type === 'fullState') {
        // Received full state sync
        console.log('[Show Mode] Received full state from host');

        if (!this.isHost) {
          this.applyFullState(data.state);
        }
      }
    } catch (error) {
      console.error('[Show Mode] Error handling peer data:', error);
    }
  }

  hookIntoMesh() {
    // Only hook once to prevent nested overrides
    if (this.isHooked) return;
    this.isHooked = true;

    // Override mesh's broadcast to also send via PeerJS
    const originalBroadcast = this.rappMesh.broadcastOperation.bind(this.rappMesh);

    this.rappMesh.broadcastOperation = (operation) => {
      // Call original localStorage broadcast
      originalBroadcast(operation);

      // Also broadcast via PeerJS if hosting
      if (this.isHost && this.connections.size > 0) {
        this.broadcastToPeers({
          type: 'operation',
          operation: operation
        });
      }
    };
  }

  broadcastToPeers(data) {
    this.connections.forEach((conn, peerId) => {
      if (conn && conn.open) {
        try {
          conn.send(data);
        } catch (error) {
          console.error('[Show Mode] Failed to send to peer:', peerId, error);
        }
      }
    });
  }

  sendFullState(conn) {
    // Send complete RAPP state to new peer
    const state = {
      chats: this.rappMesh.appState.chats,
      settings: this.rappMesh.appState.settings,
      currentChatId: this.rappMesh.appState.currentChatId
    };

    try {
      conn.send({
        type: 'fullState',
        state: state
      });
    } catch (error) {
      console.error('[Show Mode] Failed to send full state:', error);
    }
  }

  applyFullState(state) {
    // Apply received state from host
    if (state.chats) {
      this.rappMesh.appState.chats = state.chats;
    }
    if (state.settings) {
      this.rappMesh.appState.settings = state.settings;
    }
    if (state.currentChatId) {
      this.rappMesh.appState.currentChatId = state.currentChatId;
    }

    this.rappMesh.appState.saveState();

    // Trigger UI refresh
    if (window.chatApp) {
      window.chatApp.loadChats();
      if (state.currentChatId) {
        window.chatApp.loadChat(state.currentChatId);
      }
    }

    this.showNotification(' RAPP state synchronized!');
  }

  generateQRCode(url) {
    const canvas = document.getElementById('qr-code-canvas');
    if (!canvas) return;

    try {
      if (window.QRious) {
        new QRious({
          element: canvas,
          value: url,
          size: 250,
          background: 'white',
          foreground: 'black',
          level: 'H'
        });
      } else {
        console.warn('[Show Mode] QRious library not loaded');
      }
    } catch (error) {
      console.error('[Show Mode] Failed to generate QR code:', error);
    }
  }

  showWelcomeQRCode(url) {
    console.log('[Show Mode] showWelcomeQRCode called with URL:', url);

    const chatMessages = document.getElementById('chat-messages');
    const welcomeIcon = document.getElementById('welcome-icon');

    console.log('[Show Mode] chatMessages element:', chatMessages ? 'found' : 'NOT FOUND');
    console.log('[Show Mode] welcomeIcon element:', welcomeIcon ? 'found' : 'NOT FOUND');

    if (!chatMessages || !welcomeIcon) {
      console.error('[Show Mode] Required elements not found in DOM!');
      return;
    }

    console.log('[Show Mode] chatMessages.children.length:', chatMessages.children.length);

    // Only show if chat is empty
    if (chatMessages.children.length <= 1) { // Only welcome-icon present
      console.log('[Show Mode] Chat is empty, showing QR code on welcome screen');
      welcomeIcon.style.display = 'block';

      const square = welcomeIcon.querySelector('.welcome-icon-square');
      const text = welcomeIcon.querySelector('.welcome-text');

      console.log('[Show Mode] square element:', square ? 'found' : 'NOT FOUND');
      console.log('[Show Mode] text element:', text ? 'found' : 'NOT FOUND');

      // Clear square, remove connecting state, and add QR code
      square.innerHTML = '';
      square.style.animation = ''; // Clear any animations
      square.classList.add('qr-active');

      // Create canvas for QR code
      const canvas = document.createElement('canvas');
      square.appendChild(canvas);

      // Generate QR code
      try {
        if (window.QRious) {
          console.log('[Show Mode] Generating QR code with QRious...');
          new QRious({
            element: canvas,
            value: url,
            size: 120,
            background: 'white',
            foreground: 'black',
            level: 'H'
          });
          console.log('[Show Mode]  QR code generated successfully!');
        } else {
          console.error('[Show Mode] QRious library not available!');
        }
      } catch (error) {
        console.error('[Show Mode] Failed to generate welcome QR code:', error);
      }

      // Update text
      text.innerHTML = 'Scan to join this RAPP<br>from another device';
      text.classList.add('sharing-active');
      console.log('[Show Mode] Welcome text updated');
    } else {
      console.log('[Show Mode] Chat not empty, skipping QR code display');
    }
  }

  hideWelcomeQRCode() {
    const welcomeIcon = document.getElementById('welcome-icon');
    if (welcomeIcon) {
      welcomeIcon.style.display = 'none';

      const square = welcomeIcon.querySelector('.welcome-icon-square');
      const text = welcomeIcon.querySelector('.welcome-text');

      square.classList.remove('qr-active');
      square.innerHTML = '';
      text.classList.remove('sharing-active');
      text.innerHTML = 'Welcome to RAPP<br>Start a conversation below';
    }
  }

  showConnectingState() {
    const chatMessages = document.getElementById('chat-messages');
    const welcomeIcon = document.getElementById('welcome-icon');

    if (!chatMessages || !welcomeIcon) {
      console.error('[Show Mode] Required elements not found for connecting state');
      return;
    }

    // Only show if chat is empty
    if (chatMessages.children.length <= 1) {
      welcomeIcon.style.display = 'block';

      const square = welcomeIcon.querySelector('.welcome-icon-square');
      const text = welcomeIcon.querySelector('.welcome-text');

      // Show pulsing animation while connecting
      square.innerHTML = '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 48px; opacity: 0.7;"></div>';
      square.style.animation = 'pulse 2s ease-in-out infinite';

      // Update text
      text.innerHTML = 'Connecting to P2P network...<br>QR code will appear shortly';
      text.style.color = 'var(--primary)';
      console.log('[Show Mode] Showing connecting state on welcome screen');

      // Timeout fallback - if peer doesn't connect in 15 seconds, show error
      this.connectionTimeout = setTimeout(() => {
        if (!this.peer || !this.peer.id) {
          console.warn('[Show Mode] Peer connection timeout - showing fallback message');
          square.style.animation = '';
          square.innerHTML = '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 48px; opacity: 0.5;"></div>';
          text.innerHTML = 'P2P network unavailable<br>Chat still works normally!';
          text.style.color = 'var(--gray-60)';
        }
      }, 15000);
    }
  }

  updateViewerCount() {
    const count = this.connections.size;
    document.getElementById('show-mode-viewer-count').textContent = count;
  }

  showNotification(message) {
    if (window.rappMeshUI) {
      window.rappMeshUI.showNotification('info', message);
    } else {
      console.log('[Show Mode]', message);
    }
  }
}

class DistributedRAPPMesh {
  constructor(appState, options = {}) {
    this.nodeId = this.generateNodeId();
    this.appState = appState;

    // P2P networking
    this.peers = new Map(); // peerId -> { connection, channel, metadata, vectorClock }
    this.pendingConnections = new Set();

    // Distributed state management
    this.operationLog = []; // Ordered log of all operations
    this.vectorClock = {}; // Track causality {nodeId: version}
    this.vectorClock[this.nodeId] = 0;

    // State synchronization
    this.pendingOperations = []; // Operations waiting for propagation
    this.acknowledgedOps = new Set(); // Operations confirmed by quorum

    // Compute distribution
    this.workQueue = []; // Tasks to be distributed
    this.activeJobs = new Map(); // jobId -> job metadata
    this.nodeCapabilities = this.measureCapabilities();

    // Configuration
    this.config = {
      quorumSize: options.quorumSize || 2, // Minimum nodes for consensus
      syncInterval: options.syncInterval || 2000, // State sync frequency
      heartbeatInterval: options.heartbeatInterval || 3000,
      operationBatchSize: options.operationBatchSize || 10,
      enableSharding: options.enableSharding || false,
      ...options
    };

    // Signaling (localStorage for cross-browser communication)
    this.signalingKey = 'rapp-mesh-signaling';
    this.presenceKey = 'rapp-mesh-presence';

    // WebRTC configuration
    this.rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // Event handlers
    this.handlers = {
      stateSync: null,
      operationReceived: null,
      peerJoined: null,
      peerLeft: null,
      consensusReached: null,
      conflictResolved: null
    };

    this.init();
  }

  generateNodeId() {
    const browser = this.detectBrowser();
    return `${browser.name}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  detectBrowser() {
    const ua = navigator.userAgent;
    let name = 'Unknown', version = 'Unknown', engine = 'Unknown';

    if (ua.indexOf('Firefox') > -1) {
      name = 'Firefox'; engine = 'Gecko';
      version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Edg') > -1) {
      name = 'Edge'; engine = 'Blink';
      version = ua.match(/Edg\/(\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Chrome') > -1) {
      name = 'Chrome'; engine = 'Blink';
      version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unknown';
    } else if (ua.indexOf('Safari') > -1) {
      name = 'Safari'; engine = 'WebKit';
      version = ua.match(/Version\/(\d+)/)?.[1] || 'Unknown';
    }

    return { name, version, engine, userAgent: ua };
  }

  measureCapabilities() {
    // Measure this node's computational capabilities
    const capabilities = {
      cpuCores: navigator.hardwareConcurrency || 2,
      memory: navigator.deviceMemory || 4, // GB
      connectionType: navigator.connection?.effectiveType || '4g',
      browser: this.detectBrowser(),
      timestamp: Date.now()
    };

    // Simple CPU benchmark
    const start = performance.now();
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
      sum += Math.sqrt(i);
    }
    capabilities.cpuScore = 1000000 / (performance.now() - start);

    return capabilities;
  }

  init() {
    console.log(`[DistributedRAPP] Node ${this.nodeId} initializing...`);
    console.log('[DistributedRAPP] Capabilities:', this.nodeCapabilities);

    // Start presence broadcasting
    this.startPresenceSystem();

    // Start signaling listener
    this.startSignalingListener();

    // Discover existing peers
    this.discoverPeers();

    // Start state synchronization
    this.startStateSyncLoop();

    // Start operation processing
    this.startOperationProcessor();

    // Intercept AppState changes
    this.interceptStateChanges();

    // Cleanup on unload
    window.addEventListener('beforeunload', () => this.shutdown());

    console.log('[DistributedRAPP] Mesh network initialized');
  }

  // ============================================================================
  // PRESENCE & DISCOVERY
  // ============================================================================

  startPresenceSystem() {
    this.broadcastPresence();

    this.presenceInterval = setInterval(() => {
      this.broadcastPresence();
      this.cleanupStalePresence();
    }, this.config.heartbeatInterval);
  }

  broadcastPresence() {
    const presence = {
      nodeId: this.nodeId,
      timestamp: Date.now(),
      browser: this.nodeCapabilities.browser,
      capabilities: this.nodeCapabilities,
      vectorClock: this.vectorClock,
      connectedPeers: Array.from(this.peers.keys()),
      operationCount: this.operationLog.length,
      state: {
        userCount: Object.keys(this.appState.users || {}).length,
        chatCount: Object.values(this.appState.chats || {})
          .reduce((sum, userChats) => sum + Object.keys(userChats).length, 0)
      }
    };

    const allPresence = this.getAllPresence();
    allPresence[this.nodeId] = presence;
    localStorage.setItem(this.presenceKey, JSON.stringify(allPresence));
  }

  getAllPresence() {
    try {
      const data = localStorage.getItem(this.presenceKey);
      return data ? JSON.parse(data) : {};
    } catch (e) {
      return {};
    }
  }

  cleanupStalePresence() {
    const allPresence = this.getAllPresence();
    const now = Date.now();
    const timeout = 15000; // 15 seconds
    let changed = false;

    Object.keys(allPresence).forEach(nodeId => {
      if (now - allPresence[nodeId].timestamp > timeout) {
        console.log(`[DistributedRAPP] Node ${nodeId} timed out`);
        delete allPresence[nodeId];
        changed = true;

        if (this.peers.has(nodeId)) {
          this.disconnectPeer(nodeId);
        }
      }
    });

    if (changed) {
      localStorage.setItem(this.presenceKey, JSON.stringify(allPresence));
    }
  }

  discoverPeers() {
    const allPresence = this.getAllPresence();

    Object.keys(allPresence).forEach(nodeId => {
      if (nodeId !== this.nodeId &&
          !this.peers.has(nodeId) &&
          !this.pendingConnections.has(nodeId)) {

        console.log(`[DistributedRAPP] Discovered new peer: ${nodeId}`);
        this.connectToPeer(nodeId);
      }
    });
  }

  // ============================================================================
  // WebRTC PEER-TO-PEER NETWORKING
  // ============================================================================

  async connectToPeer(remotePeerId) {
    if (this.pendingConnections.has(remotePeerId) || this.peers.has(remotePeerId)) {
      return;
    }

    this.pendingConnections.add(remotePeerId);
    console.log(`[DistributedRAPP] Connecting to peer ${remotePeerId}...`);

    try {
      const pc = new RTCPeerConnection(this.rtcConfig);
      const channel = pc.createDataChannel('rapp-mesh', { ordered: true });

      this.setupDataChannel(channel, remotePeerId);

      // Store peer
      const peerInfo = {
        connection: pc,
        channel: channel,
        state: 'connecting',
        vectorClock: {},
        lastSync: Date.now(),
        pendingOps: []
      };

      this.peers.set(remotePeerId, peerInfo);

      // ICE candidate handling
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          this.sendSignal({
            type: 'ice-candidate',
            candidate: event.candidate,
            from: this.nodeId,
            to: remotePeerId
          });
        }
      };

      // Connection state tracking
      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        console.log(`[DistributedRAPP] Connection state with ${remotePeerId}: ${state}`);

        if (state === 'connected') {
          peerInfo.state = 'connected';
          this.pendingConnections.delete(remotePeerId);
          this.onPeerConnected(remotePeerId);
        } else if (state === 'failed' || state === 'disconnected' || state === 'closed') {
          this.disconnectPeer(remotePeerId);
          this.pendingConnections.delete(remotePeerId);
        }
      };

      // Handle incoming data channel
      pc.ondatachannel = (event) => {
        this.setupDataChannel(event.channel, remotePeerId);
        peerInfo.channel = event.channel;
      };

      // Create and send offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      this.sendSignal({
        type: 'offer',
        offer: offer,
        from: this.nodeId,
        to: remotePeerId
      });

    } catch (error) {
      console.error(`[DistributedRAPP] Failed to connect to ${remotePeerId}:`, error);
      this.peers.delete(remotePeerId);
      this.pendingConnections.delete(remotePeerId);
    }
  }

  setupDataChannel(channel, peerId) {
    channel.onopen = () => {
      console.log(`[DistributedRAPP]  Data channel open with ${peerId}`);

      // Immediately sync state
      this.syncStateToPeer(peerId);
    };

    channel.onclose = () => {
      console.log(`[DistributedRAPP] Data channel closed with ${peerId}`);
    };

    channel.onerror = (error) => {
      console.error(`[DistributedRAPP] Channel error with ${peerId}:`, error);
    };

    channel.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handlePeerMessage(message, peerId);
      } catch (e) {
        console.error('[DistributedRAPP] Failed to parse message:', e);
      }
    };
  }

  startSignalingListener() {
    // Listen for storage events (cross-browser signaling)
    window.addEventListener('storage', (event) => {
      if (event.key === this.signalingKey && event.newValue) {
        const signals = JSON.parse(event.newValue);
        signals.forEach(signal => {
          if (signal.to === this.nodeId && !signal.processed) {
            this.handleSignal(signal);
          }
        });
      }

      if (event.key === this.presenceKey) {
        this.discoverPeers();
      }
    });

    // Poll for signals (storage events don't fire in same tab)
    setInterval(() => {
      const signals = this.getSignals();
      signals.forEach(signal => {
        if (signal.to === this.nodeId && !signal.processed) {
          this.handleSignal(signal);
          this.markSignalProcessed(signal);
        }
      });
    }, 500);
  }

  sendSignal(signal) {
    const signals = this.getSignals();
    signals.push({
      ...signal,
      timestamp: Date.now(),
      processed: false
    });

    // Keep only recent signals
    const now = Date.now();
    const recentSignals = signals.filter(s => now - s.timestamp < 30000);

    localStorage.setItem(this.signalingKey, JSON.stringify(recentSignals));
  }

  getSignals() {
    try {
      const data = localStorage.getItem(this.signalingKey);
      return data ? JSON.parse(data) : [];
    } catch (e) {
      return [];
    }
  }

  markSignalProcessed(signal) {
    const signals = this.getSignals();
    const index = signals.findIndex(s =>
      s.from === signal.from && s.to === signal.to && s.timestamp === signal.timestamp
    );

    if (index !== -1) {
      signals[index].processed = true;
      localStorage.setItem(this.signalingKey, JSON.stringify(signals));
    }
  }

  async handleSignal(signal) {
    try {
      let peer = this.peers.get(signal.from);

      if (signal.type === 'offer') {
        if (!peer) {
          const pc = new RTCPeerConnection(this.rtcConfig);

          peer = {
            connection: pc,
            channel: null,
            state: 'connecting',
            vectorClock: {},
            lastSync: Date.now(),
            pendingOps: []
          };

          this.peers.set(signal.from, peer);

          pc.onicecandidate = (event) => {
            if (event.candidate) {
              this.sendSignal({
                type: 'ice-candidate',
                candidate: event.candidate,
                from: this.nodeId,
                to: signal.from
              });
            }
          };

          pc.onconnectionstatechange = () => {
            if (pc.connectionState === 'connected') {
              peer.state = 'connected';
              this.onPeerConnected(signal.from);
            } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
              this.disconnectPeer(signal.from);
            }
          };

          pc.ondatachannel = (event) => {
            this.setupDataChannel(event.channel, signal.from);
            peer.channel = event.channel;
          };
        }

        await peer.connection.setRemoteDescription(new RTCSessionDescription(signal.offer));
        const answer = await peer.connection.createAnswer();
        await peer.connection.setLocalDescription(answer);

        this.sendSignal({
          type: 'answer',
          answer: answer,
          from: this.nodeId,
          to: signal.from
        });

      } else if (signal.type === 'answer' && peer) {
        await peer.connection.setRemoteDescription(new RTCSessionDescription(signal.answer));

      } else if (signal.type === 'ice-candidate' && peer) {
        await peer.connection.addIceCandidate(new RTCIceCandidate(signal.candidate));
      }
    } catch (error) {
      console.error('[DistributedRAPP] Signal handling error:', error);
    }
  }

  sendToPeer(peerId, message) {
    const peer = this.peers.get(peerId);
    if (peer && peer.channel && peer.channel.readyState === 'open') {
      peer.channel.send(JSON.stringify(message));
      return true;
    }
    return false;
  }

  broadcast(message, excludePeerId = null) {
    let sent = 0;
    this.peers.forEach((peer, peerId) => {
      if (peerId !== excludePeerId && peer.channel && peer.channel.readyState === 'open') {
        peer.channel.send(JSON.stringify(message));
        sent++;
      }
    });
    return sent;
  }

  disconnectPeer(peerId) {
    const peer = this.peers.get(peerId);
    if (peer) {
      if (peer.channel) peer.channel.close();
      if (peer.connection) peer.connection.close();
      this.peers.delete(peerId);

      if (this.handlers.peerLeft) {
        this.handlers.peerLeft(peerId);
      }

      console.log(`[DistributedRAPP] Disconnected from ${peerId}`);
    }
  }

  // ============================================================================
  // DISTRIBUTED STATE MANAGEMENT
  // ============================================================================

  interceptStateChanges() {
    // Intercept all AppState modification methods
    const originalSaveChats = this.appState.saveChats.bind(this.appState);
    const originalSaveUsers = this.appState.saveUsers.bind(this.appState);
    const originalSaveSettings = this.appState.saveSettings.bind(this.appState);

    this.appState.saveChats = () => {
      originalSaveChats();
      this.createOperation('chats_updated', {
        chats: this.appState.chats
      });
    };

    this.appState.saveUsers = () => {
      originalSaveUsers();
      this.createOperation('users_updated', {
        users: this.appState.users
      });
    };

    this.appState.saveSettings = () => {
      originalSaveSettings();
      this.createOperation('settings_updated', {
        settings: this.appState.settings
      });
    };

    console.log('[DistributedRAPP] State change interception enabled');
  }

  createOperation(type, data) {
    // Increment vector clock
    this.vectorClock[this.nodeId]++;

    const operation = {
      id: `${this.nodeId}-${this.vectorClock[this.nodeId]}`,
      type: type,
      data: data,
      nodeId: this.nodeId,
      vectorClock: { ...this.vectorClock },
      timestamp: Date.now()
    };

    this.operationLog.push(operation);
    this.pendingOperations.push(operation);

    // Broadcast immediately
    this.broadcast({
      type: 'operation',
      operation: operation
    });

    console.log(`[DistributedRAPP] Created operation: ${operation.id}`);
  }

  handlePeerMessage(message, fromPeerId) {
    const peer = this.peers.get(fromPeerId);
    if (!peer) return;

    switch (message.type) {
      case 'operation':
        this.receiveOperation(message.operation, fromPeerId);
        break;

      case 'state_sync_request':
        this.handleStateSyncRequest(fromPeerId);
        break;

      case 'state_sync_response':
        this.handleStateSyncResponse(message.state, message.operations, fromPeerId);
        break;

      case 'operation_ack':
        this.handleOperationAck(message.operationId, fromPeerId);
        break;

      case 'vector_clock_update':
        peer.vectorClock = message.vectorClock;
        break;
    }
  }

  receiveOperation(operation, fromPeerId) {
    // Check if we've already seen this operation
    if (this.operationLog.find(op => op.id === operation.id)) {
      return; // Already processed
    }

    console.log(`[DistributedRAPP] Received operation ${operation.id} from ${fromPeerId}`);

    // Update vector clock
    Object.keys(operation.vectorClock).forEach(nodeId => {
      this.vectorClock[nodeId] = Math.max(
        this.vectorClock[nodeId] || 0,
        operation.vectorClock[nodeId]
      );
    });

    // Add to operation log
    this.operationLog.push(operation);

    // Apply operation to local state
    this.applyOperation(operation);

    // Acknowledge receipt
    this.sendToPeer(fromPeerId, {
      type: 'operation_ack',
      operationId: operation.id
    });

    // Propagate to other peers (gossip)
    this.broadcast({
      type: 'operation',
      operation: operation
    }, fromPeerId);
  }

  // Public method for applying operations from PeerJS (cross-device sync)
  applyRemoteOperation(operation) {
    // Check if we've already seen this operation
    if (this.operationLog.find(op => op.id === operation.id)) {
      console.log(`[DistributedRAPP] Operation ${operation.id} already applied`);
      return;
    }

    console.log(`[DistributedRAPP] Applying remote operation from PeerJS: ${operation.type}`);

    // Update vector clock
    if (operation.vectorClock) {
      Object.keys(operation.vectorClock).forEach(nodeId => {
        this.vectorClock[nodeId] = Math.max(
          this.vectorClock[nodeId] || 0,
          operation.vectorClock[nodeId]
        );
      });
    }

    // Add to operation log
    this.operationLog.push(operation);

    // Apply operation to local state
    this.applyOperation(operation);

    // Trigger UI update
    if (this.handlers.operationReceived) {
      this.handlers.operationReceived(operation);
    }
  }

  applyOperation(operation) {
    try {
      switch (operation.type) {
        case 'chats_updated':
          this.mergeChats(operation.data.chats);
          break;

        case 'users_updated':
          this.mergeUsers(operation.data.users);
          break;

        case 'settings_updated':
          this.mergeSettings(operation.data.settings);
          break;
      }

      if (this.handlers.operationReceived) {
        this.handlers.operationReceived(operation);
      }

    } catch (error) {
      console.error('[DistributedRAPP] Failed to apply operation:', error);
    }
  }

  mergeChats(remoteChats) {
    // CRDT-style merge: Last-Write-Wins with vector clocks
    Object.keys(remoteChats || {}).forEach(userId => {
      if (!this.appState.chats[userId]) {
        this.appState.chats[userId] = {};
      }

      Object.keys(remoteChats[userId]).forEach(chatId => {
        const remoteChat = remoteChats[userId][chatId];
        const localChat = this.appState.chats[userId][chatId];

        if (!localChat || new Date(remoteChat.updatedAt) > new Date(localChat.updatedAt)) {
          this.appState.chats[userId][chatId] = remoteChat;
        }
      });
    });

    this.appState.saveChats();
  }

  mergeUsers(remoteUsers) {
    Object.keys(remoteUsers || {}).forEach(userId => {
      const remoteUser = remoteUsers[userId];
      const localUser = this.appState.users[userId];

      if (!localUser || new Date(remoteUser.lastActive) > new Date(localUser.lastActive)) {
        this.appState.users[userId] = remoteUser;
      }
    });

    this.appState.saveUsers();
  }

  mergeSettings(remoteSettings) {
    // Merge settings with local precedence for conflicts
    this.appState.settings = {
      ...remoteSettings,
      ...this.appState.settings
    };

    this.appState.saveSettings();
  }

  // ============================================================================
  // STATE SYNCHRONIZATION
  // ============================================================================

  startStateSyncLoop() {
    setInterval(() => {
      this.syncWithPeers();
    }, this.config.syncInterval);
  }

  syncWithPeers() {
    this.peers.forEach((peer, peerId) => {
      if (peer.state === 'connected') {
        this.syncStateToPeer(peerId);
      }
    });
  }

  syncStateToPeer(peerId) {
    this.sendToPeer(peerId, {
      type: 'state_sync_request'
    });
  }

  handleStateSyncRequest(fromPeerId) {
    const peer = this.peers.get(fromPeerId);
    if (!peer) return;

    // Send our current state and operation log
    this.sendToPeer(fromPeerId, {
      type: 'state_sync_response',
      state: {
        users: this.appState.users,
        chats: this.appState.chats,
        settings: this.appState.settings,
        endpoints: this.appState.endpoints
      },
      operations: this.operationLog.slice(-100), // Last 100 operations
      vectorClock: this.vectorClock
    });
  }

  handleStateSyncResponse(remoteState, remoteOperations, fromPeerId) {
    const peer = this.peers.get(fromPeerId);
    if (!peer) return;

    peer.lastSync = Date.now();

    // Process any operations we're missing
    remoteOperations.forEach(op => {
      if (!this.operationLog.find(localOp => localOp.id === op.id)) {
        this.receiveOperation(op, fromPeerId);
      }
    });

    // Merge state (operations should have already updated it)
    // This is a fallback for any missed operations
    this.mergeChats(remoteState.chats);
    this.mergeUsers(remoteState.users);
    this.mergeSettings(remoteState.settings);

    if (this.handlers.stateSync) {
      this.handlers.stateSync(fromPeerId);
    }
  }

  handleOperationAck(operationId, fromPeerId) {
    const peer = this.peers.get(fromPeerId);
    if (peer) {
      peer.ackedOperations = peer.ackedOperations || new Set();
      peer.ackedOperations.add(operationId);
    }

    // Check if we have quorum
    const ackCount = Array.from(this.peers.values())
      .filter(p => p.ackedOperations && p.ackedOperations.has(operationId))
      .length;

    if (ackCount >= this.config.quorumSize && !this.acknowledgedOps.has(operationId)) {
      this.acknowledgedOps.add(operationId);
      console.log(`[DistributedRAPP]  Operation ${operationId} reached quorum`);

      if (this.handlers.consensusReached) {
        this.handlers.consensusReached(operationId);
      }
    }
  }

  startOperationProcessor() {
    setInterval(() => {
      if (this.pendingOperations.length > 0) {
        const batch = this.pendingOperations.splice(0, this.config.operationBatchSize);
        batch.forEach(op => {
          this.broadcast({
            type: 'operation',
            operation: op
          });
        });
      }
    }, 1000);
  }

  // ============================================================================
  // MESH STATUS & MONITORING
  // ============================================================================

  onPeerConnected(peerId) {
    console.log(`[DistributedRAPP]  Peer connected: ${peerId}`);

    if (this.handlers.peerJoined) {
      this.handlers.peerJoined(peerId);
    }

    // Request initial state sync
    this.syncStateToPeer(peerId);
  }

  getMeshStatus() {
    const allPresence = this.getAllPresence();
    const connectedPeers = Array.from(this.peers.entries())
      .filter(([_, peer]) => peer.state === 'connected')
      .map(([peerId, peer]) => ({
        id: peerId,
        browser: allPresence[peerId]?.browser || {},
        capabilities: allPresence[peerId]?.capabilities || {},
        vectorClock: peer.vectorClock,
        lastSync: peer.lastSync,
        connected: true
      }));

    const discoveredPeers = Object.keys(allPresence)
      .filter(peerId => peerId !== this.nodeId && !this.peers.has(peerId))
      .map(peerId => ({
        id: peerId,
        browser: allPresence[peerId].browser,
        capabilities: allPresence[peerId].capabilities,
        connected: false
      }));

    return {
      nodeId: this.nodeId,
      browser: this.nodeCapabilities.browser,
      vectorClock: this.vectorClock,
      connectedPeers: connectedPeers,
      discoveredPeers: discoveredPeers,
      totalPeers: connectedPeers.length + discoveredPeers.length,
      operationLogSize: this.operationLog.length,
      pendingOperations: this.pendingOperations.length,
      acknowledgedOps: this.acknowledgedOps.size
    };
  }

  // ============================================================================
  // EVENT HANDLERS
  // ============================================================================

  onStateSync(handler) {
    this.handlers.stateSync = handler;
  }

  onOperationReceived(handler) {
    this.handlers.operationReceived = handler;
  }

  onPeerJoined(handler) {
    this.handlers.peerJoined = handler;
  }

  onPeerLeft(handler) {
    this.handlers.peerLeft = handler;
  }

  onConsensusReached(handler) {
    this.handlers.consensusReached = handler;
  }

  // ============================================================================
  // SHUTDOWN
  // ============================================================================

  shutdown() {
    console.log('[DistributedRAPP] Shutting down mesh network...');

    // Remove presence
    const allPresence = this.getAllPresence();
    delete allPresence[this.nodeId];
    localStorage.setItem(this.presenceKey, JSON.stringify(allPresence));

    // Close all peer connections
    this.peers.forEach((peer, peerId) => {
      this.disconnectPeer(peerId);
    });

    // Clear intervals
    if (this.presenceInterval) clearInterval(this.presenceInterval);

    console.log('[DistributedRAPP] Shutdown complete');
  }
}

// Export
if (typeof window !== 'undefined') {
  window.DistributedRAPPMesh = DistributedRAPPMesh;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = DistributedRAPPMesh;
}

console.log('[DistributedRAPP] Module loaded - Ready for mesh networking');
  </script>
  <script>
  (function() {
    'use strict';

    console.log('[RAPP Mesh] Loading UI controller...');

    // Mesh UI Controller
    class MeshUI {
      constructor(mesh) {
        this.mesh = mesh;
        this.modal = document.getElementById('mesh-modal');
        this.banner = document.getElementById('mesh-status-banner');
        this.syncIndicator = document.getElementById('mesh-sync-indicator');
        this.meshButton = document.getElementById('mesh-status-btn');
        this.bannerDismissed = false;
        this.firstPeerConnected = false;
        this.setupEventListeners();
        this.startUpdateLoop();
      }

      setupEventListeners() {
        // Modal controls
        this.meshButton.addEventListener('click', () => {
          this.showModal();
        });

        document.getElementById('mesh-close-btn').addEventListener('click', () => {
          this.hideModal();
        });

        this.modal.addEventListener('click', (e) => {
          if (e.target === this.modal) this.hideModal();
        });

        // Banner controls
        document.getElementById('mesh-banner-close').addEventListener('click', () => {
          this.hideBanner();
          this.bannerDismissed = true;
        });

        document.getElementById('mesh-banner-view').addEventListener('click', () => {
          this.showModal();
        });

        document.getElementById('mesh-banner-test').addEventListener('click', () => {
          this.testSync();
        });

        // Mesh actions
        document.getElementById('mesh-open-new-window').addEventListener('click', () => {
          window.open(window.location.href, '_blank', 'width=1200,height=800');
          this.showNotification('info', 'New window opened - will join mesh automatically!');
        });

        document.getElementById('mesh-force-sync').addEventListener('click', () => {
          this.showSyncIndicator();
          this.mesh.peers.forEach((peer, peerId) => {
            if (peer.state === 'connected') {
              this.mesh.syncStateToPeer(peerId);
            }
          });
          this.showNotification('success', 'Force sync triggered to all peers');
        });

        // Mesh events
        this.mesh.onPeerJoined((peerId) => {
          this.addLog('success', ` Browser connected: ${peerId.substr(0, 20)}...`);
          this.showNotification('success', ' New browser joined the mesh!');
          this.updatePeerDisplay();
          this.updateBanner();
          this.activateMeshButton();

          // Auto-show banner on first peer
          if (!this.firstPeerConnected) {
            this.firstPeerConnected = true;
            setTimeout(() => {
              if (!this.bannerDismissed) {
                this.showBanner();
              }
              // Auto-open modal on first connection
              setTimeout(() => {
                this.showModal();
                this.showNotification('info', ' The mesh modal shows real-time sync status!');
              }, 2000);
            }, 500);
          } else if (!this.bannerDismissed) {
            this.showBanner();
          }
        });

        this.mesh.onPeerLeft((peerId) => {
          this.addLog('warning', `Browser disconnected: ${peerId.substr(0, 20)}...`);
          this.updatePeerDisplay();
          this.updateBanner();

          const status = this.mesh.getMeshStatus();
          if (status.connectedPeers.length === 0) {
            this.deactivateMeshButton();
            this.hideBanner();
          }
        });

        this.mesh.onOperationReceived((op) => {
          this.addLog('info', ` Received: ${op.type}`);
          this.showSyncIndicator();
          this.showNotification('info', ` Synced: ${op.type.replace('_', ' ')}`);
        });

        this.mesh.onStateSync((peerId) => {
          this.addLog('info', ` Synced with ${peerId.substr(0, 20)}...`);
          this.showSyncIndicator();
        });
      }

      testSync() {
        const testChat = {
          id: `test-${Date.now()}`,
          title: ` Test Chat from ${this.mesh.nodeCapabilities.browser.name}`,
          messages: [
            {
              role: 'user',
              content: `This is a test message from ${this.mesh.nodeCapabilities.browser.name} at ${new Date().toLocaleTimeString()}`,
              timestamp: Date.now()
            },
            {
              role: 'assistant',
              content: ` P2P Mesh is working! This message synced across all browsers instantly.`,
              timestamp: Date.now() + 100
            }
          ],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          archived: false
        };

        const userId = Object.keys(window.appState.users)[0] || 'test-user';

        if (!window.appState.chats[userId]) {
          window.appState.chats[userId] = {};
        }

        window.appState.chats[userId][testChat.id] = testChat;
        window.appState.saveChats();

        this.showNotification('success', ' Test data synced! Check other browsers!');
        this.addLog('success', ` Created test chat: ${testChat.title}`);
      }

      showBanner() {
        this.banner.classList.add('active');
      }

      hideBanner() {
        this.banner.classList.remove('active');
      }

      updateBanner() {
        const status = this.mesh.getMeshStatus();
        document.getElementById('mesh-banner-count').textContent = status.connectedPeers.length;

        const peersContainer = document.getElementById('mesh-banner-peers');
        peersContainer.innerHTML = status.connectedPeers.slice(0, 4).map(peer => `
          <div class="mesh-banner-peer-icon">
            ${this.getBrowserIcon(peer.browser.name)}
          </div>
        `).join('');

        if (status.connectedPeers.length > 4) {
          peersContainer.innerHTML += `<div class="mesh-banner-peer-icon">+${status.connectedPeers.length - 4}</div>`;
        }
      }

      showSyncIndicator() {
        this.syncIndicator.classList.add('active');
        setTimeout(() => {
          this.syncIndicator.classList.remove('active');
        }, 1500);
      }

      activateMeshButton() {
        this.meshButton.classList.add('mesh-active');
      }

      deactivateMeshButton() {
        this.meshButton.classList.remove('mesh-active');
      }

      showModal() {
        this.modal.classList.add('active');
        this.updatePeerDisplay();
      }

      hideModal() {
        this.modal.classList.remove('active');
      }

      startUpdateLoop() {
        setInterval(() => {
          this.updateStats();
          this.updatePeerCount();
        }, 1000);
      }

      updateStats() {
        const status = this.mesh.getMeshStatus();
        document.getElementById('mesh-connected-count').textContent = status.connectedPeers.length;
        document.getElementById('mesh-operation-count').textContent = status.operationLogSize;
        document.getElementById('mesh-sync-count').textContent = status.syncCount;
        document.getElementById('mesh-node-browser').textContent = status.browser.name.substr(0, 6);
      }

      updatePeerCount() {
        const status = this.mesh.getMeshStatus();
        const badge = document.getElementById('mesh-peer-count');
        if (status.connectedPeers.length > 0) {
          badge.textContent = status.connectedPeers.length;
          badge.style.display = 'flex';
        } else {
          badge.style.display = 'none';
        }
      }

      updatePeerDisplay() {
        const status = this.mesh.getMeshStatus();
        const container = document.getElementById('mesh-peer-list');
        const countEl = document.getElementById('mesh-peer-list-count');

        countEl.textContent = status.connectedPeers.length;

        if (status.connectedPeers.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--gray-80); grid-column: 1 / -1;">
              <i class="fas fa-info-circle" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></i>
              <p>No other browsers detected yet.</p>
              <p style="margin-top: 8px; font-size: 14px;">Open RAPP in Chrome, Firefox, Safari, or Edge!</p>
            </div>
          `;
          return;
        }

        container.innerHTML = status.connectedPeers.map(peer => `
          <div class="mesh-peer">
            <div class="mesh-peer-icon ${this.getBrowserClass(peer.browser.name)}">
              ${this.getBrowserIcon(peer.browser.name)}
            </div>
            <div class="mesh-peer-info">
              <div class="mesh-peer-name">${peer.browser.name} ${peer.browser.version}</div>
              <div class="mesh-peer-id">${peer.id}</div>
              <div class="mesh-peer-status">Last sync: ${Math.round((Date.now() - peer.lastSync) / 1000)}s ago</div>
            </div>
            <div class="mesh-peer-badge connected"> Connected</div>
          </div>
        `).join('');
      }

      getBrowserClass(name) {
        const n = (name || '').toLowerCase();
        if (n.includes('chrome')) return 'chrome';
        if (n.includes('firefox')) return 'firefox';
        if (n.includes('safari')) return 'safari';
        if (n.includes('edge')) return 'edge';
        return 'unknown';
      }

      getBrowserIcon(name) {
        const n = (name || '').toLowerCase();
        if (n.includes('chrome')) return '';
        if (n.includes('firefox')) return '';
        if (n.includes('safari')) return '';
        if (n.includes('edge')) return '';
        return '';
      }

      addLog(type, message) {
        const log = document.getElementById('mesh-activity-log');
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = 'mesh-log-entry';
        entry.innerHTML = `
          <div class="mesh-log-time">[${timestamp}]</div>
          <div class="mesh-log-message ${type}">${message}</div>
        `;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;

        while (log.children.length > 50) {
          log.removeChild(log.firstChild);
        }
      }

      showNotification(type, message) {
        const notification = document.createElement('div');
        notification.className = `mesh-notification ${type}`;
        let icon = type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle';
        notification.innerHTML = `<i class="fas fa-${icon}"></i><span>${message}</span>`;
        document.body.appendChild(notification);
        setTimeout(() => notification.classList.add('active'), 10);
        setTimeout(() => {
          notification.classList.remove('active');
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }
    }

    // Initialize mesh when AppState is ready
    function initMesh() {
      if (typeof window.appState === 'undefined') {
        setTimeout(initMesh, 100);
        return;
      }

      console.log('[RAPP Mesh] Initializing...');

      const mesh = new DistributedRAPPMesh(window.appState, {
        quorumSize: 1,
        syncInterval: 3000
      });

      const meshUI = new MeshUI(mesh);

      window.rappMesh = mesh;
      window.rappMeshUI = meshUI;

      // Initialize Show Mode Manager for cross-device P2P sync
      window.showModeManager = new ShowModeManager(mesh);
      console.log('[Show Mode]  Cross-device sync ready');

      console.log('[RAPP Mesh]  System initialized');
      console.log('[RAPP Mesh] Open RAPP in other browsers to form mesh!');
      console.log('[RAPP Mesh]  Click "Share (QR Code)" to sync across devices!');
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMesh);
    } else {
      initMesh();
    }
  })();
  </script>
</body>

</html>
